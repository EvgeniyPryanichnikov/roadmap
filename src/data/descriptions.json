[
  {  
    "parent": "Семантические элементы",
    "title": "Семантические элементы",
    "text": "<b>Семантические элементы HTML</b> — это теги, которые явно описывают содержимое веб-страницы.<br><br>Некоторые распространённые семантические элементы и их назначение:<br><br><b>header</b> используется для выделения верхней части веб-страницы, которая содержит заголовок или логотип, навигационные ссылки и другие элементы, общие для всех страниц сайта<br><br><b>nav</b>  Обозначает раздел веб-страницы, содержащий навигационные ссылки.<br><br><b>main</b> Выделяет основную часть содержимого веб-страницы.<br><br><b>article</b> Используется для обозначения самостоятельного содержимого, которое может быть независимо распространено или повторно использовано.<br><br><b>section</b> Определяет разделы документа, такие как главы, части или другие логические группы контента<br><br><b>aside</b> Тег для дополнительного контента, используется для создания сайдбара или бокового меню на сайтах.<br><br><b>footer</b> Тег с информацией о разделе. Например, это могут быть данные о том, когда была написана статья, её авторе и пр.<br><br>Семантические элементы помогают создать структурированную и понятную веб-страницу, что улучшает пользовательский опыт и SEO (поисковую оптимизацию)."
  },

  {  
    "parent": "Формы и валидация",
    "title": "Формы и валидация",
    "text": "Примеры атрибутов для валидации:<br><br><b>required</b> – проверка обязательных полей<br><br><b>maxlength</b> – ограничение на количество символов<br><br><b>max, min</b> - диапазон между максимумом и минимумом<br><br><b>pattern</b> - Атрибут паттерн использует регулярное выражение для валидаций этого поля."
  },

  {  
    "parent": "Кроссбраузерная вёрстка",
    "title": "Кроссбраузерная вёрстка",
    "text": "Чтобы сделать сайт кроссбраузерным, можно предпринять следующие шаги:<br><br><b>1.Применить CSS-хаки.<br></b>Это элементы кода, которые понимает только один браузер.Они помогают настроить отображение элементов ресурса под каждую программу.<br><br><b>2.Использовать вендорные префиксы.<br></b>В каждом браузере есть свои вендорные префиксы и уникальные свойства. Например, в Mozilla Firefox это свойство moz-border-radius, в Safari и Chrome — webkit-border-radius. Они способны менять поведение элемента, не влияя на другие браузеры.<br><br><b>3.Ввести универсальные элементы.<br></b> Они эффективно работают в подавляющем большинстве браузеров.Если использовать только их, то код будет понятным, эстетичным и чистым.Проверить, какие элементы поддерживают разные браузеры, можно в сервисе caniuse.com.<br><br>4.Для проверки кроссбраузерности сайта можно использовать <b>специальные сервисы</b>, например: CrossBrowserTesting, MultiBrowser, Litmus, Equafy, Sauce Labs."
    
  },

  {  
    "parent": "Основы SEO",
    "title": "Основы SEO",
    "text": "SEO-база состоит из:<br><b>1.Метатегов.</b> Они же HTML-теги. Их предназначение — предоставление структурированной информации о странице веб-сайта. Метатеги — помощники поисковых роботов, которые дают им возможность распознать тематику страницы и ее содержимое. HTML-теги должны быть понятными для поисковика — это повышает сайт в выдаче по ключевому запросу. <br><br><b>2.Понятного человеческого  URL.</b>ЧПУ расшифровывается как человекопонятный URL. Под ним подразумевается URL-путь, который состоит из понятных слов. Он должен отражать структуру файлов сайта. Вместо  /c65/4/97/ должно быть /korol-anglijskogo-repa-mf-doom/.<br><br><b>3.Навигационной цепочки.</b>Они же хлебные крошки. Представляют собой цепочку из ссылок, по которой пользователи могут перемещаться по сайту — от главной страницы до определенной рубрики. Цепочки навигации — один из способов связывания страниц сайта между собой с помощью гиперссылок. <br><br><b>4.Robots.txt</b> — стандарты для поисковых роботов из разряда: “Здесь можно смотреть, а тут нельзя”. Можно ограничить доступ к контенту на http-сервере, если добавить текстовый файл robots.txt.<br><br><b>5.Ошибок 404.</b> Такие ошибки являются кодом ответа сервера. Они появляются, когда браузер не смог обнаружить на серверах указанный URL. То есть, вы зашли на сайт, но страница была удалена. Либо у вас к ней по каким-то причинам нет доступа.<br><br><b>6.Удаления дублей.</b> Страницы-дубли — это страницы, которые имеют разный адрес, но контент на них либо полностью, либо наполовину совпадает.  Дубли страниц мешают сайту полноценно индексироваться в поисковой системе. Все критерии, тонкости, сложные аббревиатуры… Они необходимы, чтобы ваш сайт был в ТОПе поисковой выдачи. Чем больше юзеров перешло на ваш сайт, тем выше вероятность, что на вашем сайте произойдет активное действие — покупка товаров или услуг.  Давайте проведем логическую цепочку. Нет SEO — нет хорошей поисковой выдачи. Нет поисковой выдачи — нет пользователей. Нет пользователей — нет монетизации. Нет монетизации — нет денег. Все просто!"  
  },

  {  
    "parent": "БЭМ",
    "title": "БЭМ",
    "text": "<b>БЭМ</b> (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке, в основе которого лежит принцип разделения интерфейса на независимые блоки.<br><br>Чтобы ускорить разработку, необходимо было облегчить поддержку HTML и CSS отдельных компонентов страницы, сделать код менее связанным. Для этого мы разбили страницу на части. Так появилось новое понятие — блок. Блок мог состоять из различных элементов, которые не использовались вне самого блока. Состояния и поведение блока и элемента можно было задавать с помощью модификатора.<br><br>Это были три ключевых понятия, на которых основывалось большинство правил. Аббревиатура от трех слов Блок, Элемент и Модификатор стала названием методологии — БЭМ.<br><br><b>Блок</b></><br>Логически и функционально независимый компонент страницы. Блок полностью самодостаточен. Блоки могут использоваться в любом месте страницы, повторно, даже в другом проекте.<br><br><b>Элемент</b><br>Часть блока, которая не может использоваться в отрыве от него и имеет смысл только в рамках своего родителя. Элементы могут быть обязательными и опциональными.<br><br><b>Модификатор</b><br>Свойство блока или элемента, которое меняет их внешний вид, состояние или поведение.<br>Модификатор имеет имя и может иметь значение. Использование модификаторов опционально.У блока/элемента может быть несколько разных модификаторов одновременно.<br>Элемент отделяется от блока двумя подчеркиваниями (__). Модификатор — одним (_).<br>Пример:<br><b>•Имя блока</b> — header.<br><br><b>•Имя элемента блока</b> — header__search-form — элемент search-form блока header<br><br><b>•Имя модификатора блока</b> — header_theme_green-forest — модификатор theme в значении green-forest блока header.<br><br><b>•Имя модификатора элемента</b> — header__search-form_disabled — булев модификатор disabled элемента search-form блока header."  
  },

  {  
    "parent": "Блочная модель",
    "title": "Блочная модель",
    "text": "<b>Блочная модель CSS</b> — это алгоритм расчёта размеров каждого отдельного элемента на странице, которым браузеры пользуются при отрисовке.  <br><br>Блочная модель состоит из четырёх частей:  <br><b>Содержимое (content)</b> - Область, в которой отображается фактическое содержимое элемента (например, текст, изображения). <br><br><b>Внутренний отступ (padding)</b> - Пространство между содержимым и границей.<br><br><b>Рамка (border)</b> - Линия, которая окружает содержимое и отступы. <br><br><b>Внешний отступ (margin)</b> - Пространство между границей и соседними элементами. <br><br>По умолчанию для блочной модели свойство box-sizing установлено в значение <b>content-box</b>, что означает, что размер элемента определяется размером его содержимого. <br>Изменив значение на <b>border-box</b>, можно изменить алгоритм расчёта таким образом, чтобы он включал отступы и границы в общий размер блочного элемента."  
  },

  {  
    "parent": "Медиа-запросы",
    "title": "Медиа-запросы",
    "text": "<b>Медиа-запросы (media queries)</b> – это правила CSS, которые позволяют управлять стилями элементов в зависимости от значений технических параметров устройств.<br><br>В <b>@media</b> можно указывать <b>определённые типы устройств: </b><br><b>all</b> – для всех;<br><b>print</b> – для принтеров и в режиме предварительного просмотра страницы перед печатью;<br><b>screen</b> – для устройств с экранами;•<br><b>speech</b> – для программ чтения с экрана.<br><br>Media Queries Level 4 – это четвертая редакция спецификации для <b>@media</b><br>В ней определён <u>новый и более простой синтаксис</u> для создания диапазона: <br><font color=\"red\"><b>*</b></font> Например: @media (992px <= width < 1200px) эквивалентно @media (min-width: 992px) and (max-width: 1199.98px)<br><br>Кроме этого, Media Queries Level 4 включает четыре медиа-функции, которые относятся к категории взаимодействия: pointer, any-pointer, hover и any-hover. С помощью них можно адаптировать сайты и веб-приложения для различных устройств в зависимости от наличия у них указателя, а также от того на сколько он точен.<br>Функция hover позволяет определить, может ли основное устройство ввода наводить курсор на элементы. Она принимает два значения: hover и none.<br>Термин <b>отзывчивый дизайн</b> сегодня отражает уже очень многое. У нас есть медиа-запросы, которые проверяют пользовательские настройки, а также современные возможности CSS, которые помогают создавать отзывчивые макеты вообще без использования медиа-запросов."  
  },

  {  
    "parent": "Flexbox",
    "title": "Flexbox",
    "text": "<b>Flexbox</b> (от англ. flex — гибкий) — это модуль CSS, который позволяет удобно управлять расположением, порядком, размерами и отступами между элементами веб-страницы. <br><br><b>Flexbox</b> состоит из гибкого контейнера (flex container) и гибких элементов (flex items). Гибкие элементы могут выстраиваться в строку или столбик, а оставшееся свободное пространство распределяется между ними различными способами.<br><br>Flexbox позволяет решать <b>следующие задачи:</b><br><b>1.</b> Располагать элементы в одном из четырёх направлений: слева направо, справа налево, сверху вниз или снизу вверх;  <br><b>2.</b> Переопределять порядок отображения элементов;  flex order. Элементы Flex с установленными на них бОльшими значениями order будут отображаться позже в порядке отображения, чем элементы с меньшими значениями порядка.<br><b>3.</b> Автоматически определять размеры элементов таким образом, чтобы они вписывались в доступное пространство;  <br><b>4.</b> Решать проблему с горизонтальным и вертикальным центрированием;  <br><b>5.</b> Переносить элементы внутри контейнера, не допуская его переполнения.  <br><br>Flexbox подходит для создания адаптивных веб-страниц, то есть сайтов, которые выглядят хорошо на разных устройствах: ПК, ноутбуках, планшетах и смартфонах.  <br><br>Вот некоторые свойства Flexbox:<br><br><b>flex-direction</b> - Определяет направление основной и поперечной осей в контейнере. Может принимать четыре значения: row (по умолчанию), row-reverse, column и column-reverse.  <br><br><b>flex-wrap</b> - Определяет, будут ли flex-элементы переноситься на другую строку, если им не хватит места в ряду. Может принимать одно из трёх значений: nowrap (по умолчанию), wrap и wrap-reverse.  <br><br><b>flex-flow</b> - Объединяет в одно свойство flex-direction и flex-wrap, позволяя задать их значения в одной строке.  <br><br><b>justify-content</b> - Определяет, как будут распределены элементы вдоль главной оси. Имеет 10 значений, но стабильно во всех браузерах работают следующие: flex-start, flex-end, center, space-between, space-around и space-evenly.  <br><br><b>align-items</b> - Выравнивает содержимое контейнера вдоль по поперечной оси. У свойства есть пять возможных значений: flex-start, flex-end, center, baseline и stretch.  <br><br><b>order</b> -Устанавливает порядок расположения элементов во flex-контейнере относительно друг друга. В качестве значения order принимает любое целое число: чем оно меньше, тем ближе к началу главной оси будет расположен элемент."  
  },

  {  
    "parent": "CSS-Grid",
    "title": "CSS-Grid",
    "text": "<b>Grid Layout</b> — это модуль CSS, который определяет систему макета на основе двумерной сетки. Она оптимизирована для дизайна пользовательского интерфейса. <br><br><b>Главная идея Grid Layout</b> — разделение веб-страницы на столбцы и строки. В образовавшиеся области сетки можно помещать элементы, а управлять их размерами и расположением можно с помощью специальных свойств модуля.  <br><br>Вот некоторые <b>свойства Grid Layout</b>:<br><br>1. <b>grid-template-columns</b> — определяет количество и ширину колонок.<br><br>2. <b>grid-template-rows</b> — определяет количество и высоту строк.<br><br>3. <b>gap</b> — задает расстояние между ячейками.<br><br>4. <b>grid-column-start / grid-column-end</b> — определяет, где начинается и заканчивается элемент по горизонтали.<br><br>5. <b>grid-row-start / grid-row-end — определяет</b>, где начинается и заканчивается элемент по вертикали.<br><br>6. <b>grid-template-areas</b> — позволяет именовать области сетки и размещать элементы в этих областях."  
  },

  {  
    "parent": "Позиционирование",
    "title": "Позиционирование",
    "text": "Позиционирование в CSS осуществляется с помощью свойства <b>position</b>, которое определяет, где находится элемент на веб-странице.<br><br>Значения свойства position:<br><b>static</b> - Значение по умолчанию, элемент позиционируется в соответствии с его местом в потоке документа.<br><br><b>relative</b> - Элемент позиционируется относительно своего исходного положения в потоке документа.<br><br><b>absolute</b> - Элемент позиционируется относительно ближайшего родительского элемента, который имеет позиционирование, отличное от static.  <br><br><b>fixed</b> - Элемент позиционируется относительно окна браузера.  <br><br><b>sticky</b> - Элемент остаётся на месте при прокрутке страницы, но при этом может быть отодвинут от своей стандартной позиции.<br><br>Также существуют дополнительные свойства CSS, которые позволяют сдвинуть элемент как по горизонтальной оси (left и right), так и по вертикальной (top и bottom):<br><b>top</b> - Сдвигает элемент вниз.  <br><b>right</b> - Сдвигает элемент влево.<br><b>bottom</b> - Сдвигает элемент вверх."  
  },

  {  
    "parent": "Отображение",
    "title": "Отображение",
    "text": "Свойство <b>display</b> в CSS используется для настройки отображения элемента.Оно управляет и изменяет способ отображения элементов HTML на веб-странице.<br><br>Свойство display определяет внешние и внутренние значения отображения элемента:<br><b>1.Внешнее значение отображения</b> определяет, будет ли бокс элемента занимать всю ширину родительского контейнера или его размер будет определяться содержимым.<br><br><b>2.Внутреннее значение отображения</b> управляет расположением дочерних элементов — будут ли они придерживаться обычного потока или следовать другим параметрам расположения.<br><br>Некоторые <b>значения свойства display</b>:<br><br><b>•Inline</b> - Используется для отображения строчного элемента. Строковые элементы отображаются в одну строку, то есть горизонтально, и занимают столько ширины, сколько необходимо.<br><br><b>•Block</b> - Элемент заполняет всю ширину своего контейнера. Каждый новый элемент отображается на новой строке, если не указано иное.<br><br><b>•None</b> - Используется для отключения отображения элемента. Элемент будет отображаться так, как будто был фактически удалён и никогда не существовал."  
  },

  {  
    "parent": "SCSS",
    "title": "SCSS",
    "text": "<b>SCSS</b> — это синтаксис препроцессорного скриптового языка Sass, основанный на стандартном для CSS синтаксисе.<br><br>SCSS даёт дополнительные возможности для написания CSS-кода: <br><b>1. Вложенность селекторов</b><br><b>2. Использование переменных</b> - <b>$</b>link: #15157d;<br><b>3. Вложенные селекторы и медиазапросы; </b><br><b>4. Сбор нескольких файлов в один</b><br><b>5. Миксины</b>  - @mixin(примеси) ― это многократно используемый блок SCSS-кода.<br><b>6. Наследование</b> - <br>Это одна из самых полезных функций Sass. Используя директиву <b>@extend</b> можно наследовать наборы свойств CSS от одного селектора другому. Это позволяет держать ваш Sass-файл в «чистоте».<br><br>SCSS не подключается в браузер напрямую. Он компилируется (собирается) в привычный для браузера CSS-код, и уже CSS-файл подключается на страницу."  
  },

  {  
    "parent": "Типы данных",
    "title": "Типы данных",
    "text": "<b>1. Number</b>(infinity, NaN – вычислительная ошибка)<br><br><b>2. String</b><br><br><b>3. Boolean</b> (логический тип)<br><br><b>4. Null</b> (ничего, пусто, значение не известно)<br><br><b>5. Undefined</b> (значение не присвоено)<br><br><b>6. Обьекты</b> (не примитивный тип данных, храним коллекции данных)<br><br><b>7. Symbol</b> — это примитивный, неизменяемый тип данных в JavaScript.<br><br>Символы представляют собой уникальные идентификаторы..Для создания символа можно использовать встроенную функцию Symbol ().<br><br><b>8. Bigint</b> - это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.<br>Чтобы создать значение типа BigInt, необходимо добавить <b>n</b> в конец числового литерала или вызвать функцию BigInt, которая создаст число типа BigInt из переданного аргумента. Аргументом может быть число, строка и др.<br><br><b>В чем отличие ссылочных типов от примитивных?</b><br>Основное различие между примитивными и ссылочными типами в JavaScript заключается в следующем:<br><b>1. Примитивные типы</b> хранятся как простые типы данных. Когда вы присваиваете примитивное значение переменной, значение копируется в эту переменную.<br><b>2. Ссылочные типы данных</b>, они же – объекты (объекты, массивы и функции), это области памяти неопределенного размера и доступные по идентификатору.Они содержат ссылку на местоположение в памяти."  
  },

  {  
    "parent": "Преобразование типов",
    "title": "Преобразование типов",
    "text": "Преобразование может быть <b>явным</b> и <b>неявным</b>: <br><br><b>Явное преобразование</b> - Разработчик явно указывает в коде программы преобразование типов, например, с помощью функций Number() или String().<br><b>Неявное преобразование</b> - Происходит автоматически в процессе выполнения операций. Обычно такое случается, когда в выражениях используют значения различных типов или в зависимости от контекста выражения.<br><br><b>1. Строковое преобразование</b> - преобразование происходит очевидным образом. false становится \"false\", null становится \"null\" и т.п. String(value)<br><br><b>2. Численное преобразование </b>происходит в математических функциях и выражениях.<br>Например, когда операция деления / применяется не к числу.<br><u>Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN.</u><br><br>Мы можем использовать функцию <b>Number(value) </b> или <b>+</b>, чтобы явно преобразовать value к числу.<br><br><b>Правила численного преобразования</b>:<br>Undefined преобразуется в NaN<br>null преобразуется в 0<br>true / false преобразуется в 1 / 0<br>string - Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.<br><br><b>3. Логическое преобразование</b> – Интуитивно пустые значения 0, Null, undefined, NaN, пустая строка преобразуются в false,<br>Все остальные становятся true"  
  },

  {  
    "parent": "VAR, LET и CONST",
    "title": "VAR, LET и CONST",
    "text": "Переменные, объявленные при помощи <b>var</b>, имеют <b>глобальную</b>,  или <b> локальную (в рамках функции) </b>,  область видимости.<br><br> Если вы объявляете переменные с использованием <b>let</b> или <b>const</b>, их область видимости будет <b>блочной</b>.<br><br> Переменные, объявленные при помощи <b><u>var</u>, могут обновляться и объявляться заново</b>.<br><br> <b>Использование <u>let</u> позволяет обновлять переменную, но не объявлять заново</b>, а использование <b><u>const</u> не предполагает ни того, ни другого.</b><br><br> Переменные всех видов поднимаются в верх своей области видимости. Но переменные, объявленные при помощи <u>var</u>, инициализируются как <u>undefined</u>, а объявленные с использованием <u>let</u> или <u>const</u> — не инициализируются.<br><br> <b>При помощи var или let</b> можно объявлять переменные без их инициализации, но если вы объявляете переменную при помощи <b>const</b>, она должна инициализироваться при объявлении.<br><br><font color=\"red\"><b>*</b></font> Переменные, созданные в глобальной области видимости с помощью ключевых слов let, const и class, не являются свойствами глобального объекта."  
  },

  {  
    "parent": "Области видимости",
    "title": "Области видимости",
    "text": "<b> Область видимости</b>  в JavaScript — <b>Концепция, которая определяет границы действия переменных.</b><br><br>Область видимости решает проблему хаоса в коде. Без неё, все переменные были бы доступны везде, что приводило бы к ошибкам и конфликтам.<br> <br> Она может быть:<br> <b> Глобальная</b> Элементы программы открыты для использования в любой её части. Они объявляются за рамками функций и блоков.<br> <br> <b> Локальная</b> Элементы доступны только в определённом блоке или функции. Это помогает избежать конфликтов между элементами, объявленными в разных частях программы.<br> Локальную область видимости можно разбить на два типа:<br> <b> Функциональная</b> Зона видимости элементов, объявленных внутри функции.<br><b> Блочная</b> Зона видимости переменных, объявленных внутри блока кода."  
  },

  {  
    "parent": "Контекст и ключевое слово this",
    "title": "Контекст и ключевое слово this",
    "text": "Кроме области видимости в JavaScript имеется ещё <b>контекст</b> (context). <br><b>Контекст</b> – это то, на что указывает <b>this</b>.<br>По сути <b>this</b>– это объект, которому «принадлежит» выполняемый в данный момент код.<br><br><b>1.</b> В контексте глобального объекта (вне модулей и функций) <b>this</b>– это глобальный объект.<br><br><b>2.</b> Внутри функции <b>this</b> зависит от того, как вызывается функция:<br><br>2.1. Если функция вызывается не как метод объекта, то <b>this</b> в не строгом режиме указывает на глобальный объект, а в строгом – <b>undefined</b>.<br><br>2.2. Когда функция вызывается как метод, <b>this</b>– это объект, который использовался для его вызова<br><br><b>3.</b> Внутри класса <b>this</b> указывает на новый объект, который будет создан с помощью new:<br><br><b>4.</b> В модуле на верхнем уровне <b>this</b>– это <b>undefined</b>.<br><br><font color=\"red\"><b>*</b></font> <b>Стрелочные функции нет имеют собственного this</b>.<br>Если внутри стрелочной функции происходит обращение к <b>this</b>, она берёт его снаружи."  
  },

  {  
    "parent": "Call или Apply, Bind",
    "title": "Call или Apply, Bind",
    "text": "<h4>1.Указание контекста с помощью call или apply</h4><br>В JavaScript при вызове функции можно установить нужный this, т.е. контекст, в котором она должна выполняться. Осуществляется это с помощью <b>метода call</b> или <b>apply</b>.<br><br>Первым аргументом передаётся сам объект, следующими аргументами передаются параметры.<br><br><u>Синтаксис использования метода <b>call</b>:</u><br><br>Например:<br><b>объект user:</b><br>const user = {<br>&nbsp;&nbsp;name: 'Василий',<br>&nbsp;&nbsp;age: 27<br>}<br><b>объявление функции getAge:</b><br>const getAge = function() {<br> &nbsp;&nbsp;return this.age;<br>}<br><b>вызов функции в контексте объекта user:</b><br>console.log(getAge.call(user)); // 27<br><br><b>Метод apply</b> аналогичен call. Единственное отличие в том, что аргументы в <b>apply передаются в виде массива</b>.<br><br>В качестве thisArg методам call и apply, кроме объекта, можно также установить значение null или undefined. В не строгом режиме эти значения будут заменены ссылкой на глобальный объект. <br><br><font color=\"red\"><b>*</b></font> Call привязывает контекст и сразу же вызывает функцию.<br><br><br><br><h4>2.Метод bind</h4><br>Позволяет привязать функцию объекту в качестве метода (установить нужный this для функции), в отличие от call и apply позволяет не вызывать её сразу, а записать в переменную, чтобы использовать в дальнейшем.<br>Первым аргументом передаётся сам объект, следующими аргументами передаются параметры."  
  },

  {  
    "parent": "Контекст выполнения, Стек вызовов",
    "title": "Контекст выполнения, Стек вызовов",
    "text": "<font color=\"red\"><b>*</b></font> <b>Контекст выполнения</b> (execution context) — это, если говорить упрощённо, концепция, описывающая окружение, в котором производится выполнение кода на JavaScript. Код всегда выполняется внутри некоего контекста.<br><br><b><mark>Типы контекстов выполнения<mark></b><br><br>В JavaScript существует <b>три типа контекстов выполнения</b>:<br><b>• Глобальный контекст выполнения</b> - Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект window, и тем, что ключевое слово this указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.<br><br><b>• Контекст выполнения функции</b> -  Каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждая функция имеет собственный контекст выполнения. В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.<br><br><b>• Контекст выполнения функции eval</b> -  Код, выполняемый внутри функции eval, также имеет собственный контекст выполнения. Однако функцией eval пользуются очень редко, поэтому здесь мы об этом контексте выполнения говорить не будем. <br><br><br><h4><b>Стек вызовов</b></h4><br><font color=\"red\"><b>*</b></font> <b>Стек выполнения</b> (execution stack), который ещё называют <b>стеком вызовов</b> (call stack), это LIFO-стек, который используется для хранения контекстов выполнения, создаваемых в ходе работы кода.<br><br>Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения и помещает его в текущий стек. При обнаружении команды вызова функции движок создаёт новый контекст выполнения для этой функции и помещает его в верхнюю часть стека.<br><br>Движок выполняет функцию, контекст выполнения которой находится в верхней части стека. Когда работа функции завершается, её контекст извлекается из стека и управление передаётся тому контексту, который находится в предыдущем элементе стека."  
  },

  {  
    "parent": "Массивы",
    "title": "Массивы",
    "text": "<b>Массив</b>  – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.<br><br>Существует два варианта синтаксиса для создания пустого массива:<br><br>• let arr = new Array();<br>• let arr = [];<br><br>Cами массивы <b>являются перебираемыми объектами.</b> Но есть и много других встроенных перебираемых объектов, например, <u>строки</u>.<br><br>Свойство <u>length</u> отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.<br><br>Чтобы пройтись по элементам массива:<br><br><b>• for (let i=0;  I < arr.length;  i++)</b> – работает быстрее всего, совместим со старыми браузерами.<br><br><b>• for (let item of arr) </b>  – современный синтаксис только для значений элементов (к индексам нет доступа).<br><br><b>• for (let i in arr) </b>  – никогда не используйте для массивов.<br><br>Есть универсальный метод <b> Array.from</b> , который принимает итерируемый объект или псевдомассив и делает из него «настоящий» Array. После этого мы уже можем использовать методы массивов.<br><br><font color=\"red\"><b>*</b></font> <b>Kлонирование массива</b><br><br>• Используя метод <b>Array.slice()</b><br>• Использование оператора <b>spread</b>-<br>Оператор <u>spread</u> позволяет вам разложить массив на отдельные элементы, которые затем можно использовать для создания нового массива:<br><mark>const originalArr = [1, 2, 3];<br>const clonedArr = [...originalArr];</mark><br><br>• Используя метод <b>Array.from()</b>:<br><mark>const originalArr = [1, 2, 3];<br>const clonedArr = Array.from(originalArr)</mark><br><br>• Используя метод <b>Array.concat()</b> - <br>Этот метод создает новый массив путем объединения двух или более массивов вместе:<br><mark>const originalArr = [1, 2, 3];<br>const clonedArr = [].concat(originalArr);</mark><br><br> •Использование <b>цикла for</b><br><br> •Используя метод <b>Array.map()</b>:<br><mark>const originalArr = [1, 2, 3];<br>const clonedArr = originalArr.map(x => x);</mark><br><br><font color=\"red\"><b>*</b></font> <b>МЕТОДЫ МАССИВА:</b><br><br><b>• push()</b> – добавляет элементы в конец,<br><br><b>• pop()</b>  – извлекает элемент из конца,<br><br><b>• shift()</b> – извлекает элемент из начала,<br><br><b>• unshif)</b> – добавляет элементы в начало.<br><br><b>• splice()</b>  – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.<br><br><b>• slice()</b>  возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end)<br><br><b>• some()</b>  Этот метод проверяет, удовлетворяет ли какой-либо элемент массива условию,заданному в передаваемой функции. Он вернет значение true, если хотя бы один элемент совпадет с проверяемой функцией <mark>arr.some(el => el === \"d\")</mark><br><br><b>• every()</b> проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.<br>Он вернет значение true, если каждый элемент совпадет с проверяемой функцией, и значение false — если нет.<br><mark>arr.every(test => test === \"d\")</mark><br><br><b>• reduce()</b> принимает функцию, которая имеет в качестве аргумента аккумулятор и значение.Он применяет функцию к аккумулятору и каждому значению массива, чтобы в результате вернуть только одно значение.<br><mark> arr.reduce((total, value) => total * value)</mark><br><br><b>• map()</b>-вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.<br><br><b>• find()</b>  ищет один (первый) элемент, который заставит функцию вернуть true.<br><mark>arr.filter(item => item.id < 3)</mark><br><br><b>• filter()</b>  возвращает массив из всех подходящих элементов<br><br><b>• forEach()</b> применяет функцию к каждому элементу массива. Ничего не возвращает.<br><mark>arr.forEach(element => console.log(element.name))</mark><br><br><b>• findIndex()</b>  возвращает индекс найденного элемента, если элемент удовлетворяет условию. Если не удовлетворяет, возвращается –1<br><br><b>• includes(value) </b>  – возвращает true, если в массиве имеется элемент value, в противном случае false.<br><br><b>• split/join</b>  – преобразует строку в массив и обратно.<br><br><b>• concat()</b>  метод объединяет два или более массива/значения и возвращает новый массив//arr.concat(arr2)<br><br><b>• reverse()</b><br><b>Array.isArray(arr)</b> проверяет, является ли arr массивом."  
  },

  {  
    "parent": "Объекты",
    "title": "Объекты",
    "text": "<b>Объекты</b> – это один из типов данных в JavaScript, который предназначен для хранения коллекции различных значений и более сложных сущностей.<br><br><font color=\"red\"><b>*</b></font> Работа с любыми объектами ведется исключительно по ссылке.<br><br>Они хранят свойства (пары ключ-значение), где:<br>• Ключи свойств должны быть строками или символами (обычно строками).<br>• Значения могут быть любого типа.<br><br>Чтобы получить доступ к свойству, мы можем использовать:<br>• Запись через точку: <mark>obj.property</mark>.<br>• Квадратные скобки <mark>obj[\"property\"]</mark>. <br>Квадратные скобки позволяют взять ключ из переменной, например, <mark>obj[varWithKey] </mark>.<br><br>Дополнительные операторы:<br>• Удаление свойства: <mark>delete obj.prop</mark>.<br>• Проверка существования свойства: <mark>\"key\" in obj</mark><br>• Перебор свойств объекта: цикл <mark>for (let key in obj). </mark><br><br><font color=\"red\"><b>*</b></font> Одно из главных отличий объектов от примитивов заключается в том, что <b>объекты хранятся и копируются «по ссылке»</b>, тогда как примитивные значения – всегда копируются «как целое значение».<br><br>Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.<br><br><br><br><font color=\"red\"><b>*</b></font> <b>Сравнение по ссылке</b><br>  Два объекта равны только в том случае, если это один и тот же объект.<br><br><font color=\"red\"><b>*</b></font><b> Клонирование и объединение:</b><br><br>const food = { beef: '?', bacon: '?' }<br>// \"Spread\"<br><mark>{ ...food }</mark><br><br>// \"Object.assign\"<br> <mark>Object.assign({}, food)</mark><br><br>// \"JSON\"<br><mark>JSON.parse(JSON.stringify(food))</mark><br><br>// structuredClone<br><mark>const copied = structuredClone(calendarEvent</mark>)<br><br>• Использование <b>спред-оператора</b> или метода <b>Object.assign() (поверхностное клонирование) </b>. <br>Метод Object.assign копирует все свойства из одного или нескольких исходных объектов в один целевой объект.<br><br><b>• Преобразование объекта в строку JSON и обратно</b> Метод JSON.stringify позволяет передать объект в первом аргументе для преобразования в строковый формат. <br>После преобразования объекта в строку можно взять эту строку и преобразовать её обратно в исходный объект, используя метод JSON.parse.<br><br>• Использование глобального метода  <b>structuredClone</b>. <br>StructuredClone — Функция structuredClone создаёт новый объект с теми же свойствами, что и исходный объект, и все свойства, которые являются объектами, также клонируются."  
  },

  {  
    "parent": "Деструктуризация",
    "title": "Деструктуризация",
    "text": "<b>Деструктурирующее присваивание</b> – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.<br><br>Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее. <br><br><b>1. Деструктуризация массива</b><br><br><mark>let [firstName, surname] = \"Evgeniy Pryanichnikov\".split(\" \"); </mark><br><mark>console.log(firstName); // Evgeniy</mark><br><mark> console.log (surname);  // Pryanichnikov </mark><br><br><b>2. Остаточные параметры \"…\"</b><br>Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор <b>остаточные параметры:</b><br><br><mark>let [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"Troy\" ];</mark><br><br><font color=\"red\"><b>*</b></font> Переменная <b>rest</b> является массивом из оставшихся элементов.<br><br>Вместо rest можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании.<br><br><b>3. Деструктуризация объекта</b><br><br>let options = {<br> &nbsp;&nbsp;title: \"Menu\",<br>&nbsp;&nbsp;width: 100,<br>&nbsp;&nbsp;height: 200<br>};<br><mark>let {title, width, height} = options;</mark><br>Свойства options.title, options.width и options.height присваиваются соответствующим переменным."  
  },

  {  
    "parent": "Параметры по умолчанию",
    "title": "Параметры по умолчанию",
    "text": "<b>Параметры по умолчанию в JavaScript</b> позволяют задавать параметрам функции значения по умолчанию в случае, если функция вызвана без аргументов или если параметру явным образом передано значение undefined.<br><br>В JavaScript параметры функции, которым при её вызове не передаются значения, принимают по умолчанию значение undefined. Однако в некоторых случаях может быть полезно задать иное значение по умолчанию. Именно для таких случаев предназначены параметры по умолчанию.<br><br><font color=\"red\"><b>*</b></font> Параметры по умолчанию вычисляются в момент вызова функции.<br><br><u>Вот простой пример:</u><br><mark>let getFinalPrice = (price, tax = 0.7) => price + price * tax; </mark><br><mark>getFinalPrice(500); </mark> // 850, так как значение tax не задано<br><mark>getFinalPrice (500, 0.2); </mark> // 600, значение tax по-умолчанию заменяется на 0.2"  
  },

  {  
    "parent": "Стрелочные функции",
    "title": "Стрелочные функции",
    "text": "<b>Стрелочные функции</b> — это более компактный и удобный синтаксис для определения функций в JavaScript по сравнению с обычными функциями. <br><u>Синтаксис стрелочных функций:</u><br><br>• У них нет имени и ключевого слова function. Вместо них в круглых скобках сразу же пишутся параметры. За ними идёт стрелка  =>, а после неё — фигурные скобки с телом функции.  <br><br> • Стрелочную функцию можно записать ещё короче. Если её тело состоит из одного выражения (действия), фигурные скобки и ключевое слово return не нужны.  <br><br>Примеры стрелочных функций:<br><mark>• const sum = (a, b) => a + b;</mark><br> Задаёт функцию, которая принимает два аргумента с именами a и b.<br> И при выполнении она вычисляет выражение a + b и возвращает результат.  <br><br>• Если у функции только один параметр, круглые скобки можно отбросить <br>Например, <mark>const square = a => a * 2</mark><br><br><b>Стрелочные функции не имеют собственного контекста выполнения (this). </b><br><br><font color=\"red\"><b>*</b></font> Они берут значение this из окружающего контекста."  
  },

  {  
    "parent": "Классы",
    "title": "Классы",
    "text": "<b><mark>Что такое класс</b>?</mark><br>Это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные свойства и методы<br><br><b><mark>Что такое constructor()?</mark></b><br>Это специальный метод внутри класса, который используется для инициализации экземпляра класса, в нём устанавливаются начальные значения свойств.<br>Если не определить собственный конструктор, будет создан стандартный конструктор, представляющий собой пустую функцию, не влияющую на экземпляр.<br><br><b><mark>Свойства класса? </mark> </b><br>Свойства класса - это переменные, в которых хранится нужная информация. Свойства могут быть разделены на две группы:<ol><li>• Свойства экземпляров класса</li><li>• Статические свойства - это свойства принадлежащие всему классу в целом, а не отдельным экземплярам. Объявляются с помощью ключевого слова static. Наследуются.</p></li></ol></p><p>• Свойства также имеют два уровня доступа::<ol><li>• Открытые</li><li>• Приватные - не могут быть получены за пределами класса. Объявляют с префиксом #. Не наследуются.</li></ol></p><br><br><b><mark>Методы класса? </mark> </b><br>Это функции, с помощью которых можно получать и изменять свойства и вызывать другие методы</p><p>Методы могут быть разделены на две группы:<ol><li>Методы экземпляров класса</li><li>Статические методы - это методы, принадлежащие самому классу. Они определяют логику класса, а не его экземпляров. Объявляются с помощью ключевого слова static. Наследуются.</li></ol><p>Методы также имеют два уровня доступа::<ol><li>Открытые</li><li>Приватные - методы, которые не могут быть вызваны за пределами класса. Объявляют с префиксом #. Не наследуются</li></ol></p><br><br><b><mark>Что такое наследование классов? </mark> </b><br><p>Это способ расширения одного класса другим классом.<br>Наследование реализуется с помощью ключевого слова extends:<br>class Child extends Parent.<br>Объект класса Child будет иметь собственные методы, при этом у него будет доступ к методам Parent</p><br><br><b><mark>Что такое переопределение конструктора в классах? </mark> </b><br><p>Для переопределения в конструкторе класса необходимо вызвать сначала конструктор родителя: super(foo) и после этого будет создаваться this, который можно будет расширять или переопределять.</p><br><br><b><mark>Метод проверки относится ли объект к классу? </mark> </b><br><p>obj instanceof Class</p><br><br><b><mark>Добавление новых методов в класс? </mark> </b><br><p>Мы можем добавить новый метод в класс с помощью свойства prototype, при этом новый метод будет доступен у всех ранее созданных экземпляров класса.</p>"  
  },

  {  
    "parent": "DOM",
    "title": "DOM",
    "text": "Браузер, перед тем как показать вам запрашиваемую страницу, выполняет большое количество различных действий. Самое важное здесь понять, что <b>браузер не работает с HTML-страницей напрямую как с текстом, а строит для этого DOM</b>.<br><br><mark><b>DOM</b></mark> – это объектная модель документа (Document Object Model). Представляет она собой древовидную структуру страницы, состоящую из узлов. <br>Каждый узел в ней – это объект, который может иметь определённые свойства и методы. <br>Иными словами, можно сказать, что DOM – это набор иерархически связанных между собой объектов.<br><br><b>Зачем браузер строит DOM?</b>  <br>В основном это связано с тем, что прочитанный HTML-код ему нужно как-то представить в памяти и было решено, что оптимально это будет сделать в виде древовидной структуры. После того как браузер построил DOM, он его использует в дальнейших процессах, конечной целью которых является построение отображения этой страницы на экране.<br><br><b>Процесс перевода HTML-кода страницы в DOM выполняет парсер. </b>  <br>При этом он это делает даже если HTML-код содержит ошибки, но так как он в данном случае это «понимает».<br><br><mark>При этом <b>DOM</b> не является статической структурой. Её можно изменять с помощью JavaScript и тут же видеть эти изменения на экране.</mark><br> Для этого браузер нам предоставляет <b>API.</b> То есть благодаря DOM, мы можем с помощью JavaScript изменять содержимое страницы на лету. <br>Таким образом, JavaScript – это ключевая технология для создания динамических веб-сайтов и веб-приложений. Без неё, каким-то других способом это сделать невозможно.<br><br>Перед тем как перейти к изучению DOM, рассмотрим сначала все основные этапы работ, которые браузер выполняет для преобразования исходного кода HTML-документа в отображение стилизованной и интерактивной картинки на экране. <br>Этот процесс называется <b>Critical Rendering Path (CRP).</b>(см. следующий раздел)"  
  },

  {  
    "parent": "Critical Rendering Path (CRP)",
    "title": "Critical Rendering Path (CRP)",
    "text": "<mark><b>Критические этапы рендеринга</b></mark> (Critical Rendering Path) - это последовательность шагов, которые выполняет браузер, когда преобразуется HTML, CSS и JavaScript в пиксели, которые вы видите на экране. <br>Этот процесс называется Critical Rendering Path (CRP).<br><br><b><mark>Понимание этапов (CRP)</mark></b><br>Существует 6 этапов CRP:<br><br><b>• Построение DOM-дерева. </b> <br>Это объект, представляющий полностью разобранную HTML-страницу. Начиная с корневого элемента <html>, узлы создаются для каждого элемента/текста на странице.<br><br><b>• Построение CSSOM-дерева. </b><br>CSSOM (CSS Object Model) — это объектное представление стилей DOM.<br><br><b>• Запуск JavaScript. </b><br><br><b>• Создание Render-дерева. </b> <br> Движок браузера комбинирует DOM и CSSOM, чтобы создать дерево рендера, в котором вычисляет стили для каждого видимого элемента страницы.<br><br><b>• Генерация раскладки.</b><br> Определяет положение и размеры элементов этого дерева.<br><br><b>• Отрисовка.</b> <br>На этом шаге видимый контент страницы преобразуется в пиксели, чтобы появиться на экране.<br><br><font color=\"red\"><b>* </b></font>Загрузка веб-страницы или приложения начинается с запроса HTML. Сервер возвращает HTTP-ответ, состоящий из заголовков (headers) и тела запроса. Именно в теле запроса содержится HTML-документ. <br>Браузер начинает парсить загружаемый HTML, преобразуя полученные байты документа в DOM-дерево. Браузер создаёт новый запрос каждый раз, когда он находит ссылки на внешние ресурсы, будь то файлы стилей, скриптов или ссылки на изображения. Некоторые запросы являются блокирующими. Это означает, что пока такие запросы выполняются - другие запросы приостанавливаются. Браузер продолжает парсить HTML и создавать DOM до тех пор, пока запрос на получение HTML не подходит к концу.<br> После завершения парсинга <b>DOM</b>, браузер конструирует CSS модель.<b>(CSSOM)</b>.<br> Как только эти модели сформированы, браузер строит дерево рендера <b>(render tree)</b>, в котором вычисляет стили для каждого видимого элемента страницы. <br>После формирования дерева происходит компоновка <b>(layout)</b>, которая определяет положение и размеры элементов этого дерева. Как только этап завершён - страница рендерится. Или \"отрисовывается\" <b>(paint)</b> на экране."  
  }
]

