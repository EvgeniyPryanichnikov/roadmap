[
  {  
    "parent": "Семантические элементы",
    "title": "Семантические элементы",
    "text": "<b>Семантические элементы HTML</b> — это теги, которые явно описывают содержимое веб-страницы.<br><br>Некоторые распространённые семантические элементы и их назначение:<br><br><b>header</b> используется для выделения верхней части веб-страницы, которая содержит заголовок или логотип, навигационные ссылки и другие элементы, общие для всех страниц сайта<br><br><b>nav</b>  Обозначает раздел веб-страницы, содержащий навигационные ссылки.<br><br><b>main</b> Выделяет основную часть содержимого веб-страницы.<br><br><b>article</b> Используется для обозначения самостоятельного содержимого, которое может быть независимо распространено или повторно использовано.<br><br><b>section</b> Определяет разделы документа, такие как главы, части или другие логические группы контента<br><br><b>aside</b> Тег для дополнительного контента, используется для создания сайдбара или бокового меню на сайтах.<br><br><b>footer</b> Тег с информацией о разделе. Например, это могут быть данные о том, когда была написана статья, её авторе и пр.<br><br>Семантические элементы помогают создать структурированную и понятную веб-страницу, что улучшает пользовательский опыт и SEO (поисковую оптимизацию)."
  },

  {  
    "parent": "Формы и валидация",
    "title": "Формы и валидация",
    "text": "Примеры атрибутов для валидации:<br><br><b>required</b> – проверка обязательных полей<br><br><b>maxlength</b> – ограничение на количество символов<br><br><b>max, min</b> - диапазон между максимумом и минимумом<br><br><b>pattern</b> - Атрибут паттерн использует регулярное выражение для валидаций этого поля."
  },

  {  
    "parent": "Кроссбраузерная вёрстка",
    "title": "Кроссбраузерная вёрстка",
    "text": "Чтобы сделать сайт кроссбраузерным, можно предпринять следующие шаги:<br><br><b>1.Применить CSS-хаки.<br></b>Это элементы кода, которые понимает только один браузер.Они помогают настроить отображение элементов ресурса под каждую программу.<br><br><b>2.Использовать вендорные префиксы.<br></b>В каждом браузере есть свои вендорные префиксы и уникальные свойства. Например, в Mozilla Firefox это свойство moz-border-radius, в Safari и Chrome — webkit-border-radius. Они способны менять поведение элемента, не влияя на другие браузеры.<br><br><b>3.Ввести универсальные элементы.<br></b> Они эффективно работают в подавляющем большинстве браузеров.Если использовать только их, то код будет понятным, эстетичным и чистым.Проверить, какие элементы поддерживают разные браузеры, можно в сервисе caniuse.com.<br><br>4.Для проверки кроссбраузерности сайта можно использовать <b>специальные сервисы</b>, например: CrossBrowserTesting, MultiBrowser, Litmus, Equafy, Sauce Labs."
    
  },

  {  
    "parent": "Основы SEO",
    "title": "Основы SEO",
    "text": "SEO-база состоит из:<br><b>1.Метатегов.</b> Они же HTML-теги. Их предназначение — предоставление структурированной информации о странице веб-сайта. Метатеги — помощники поисковых роботов, которые дают им возможность распознать тематику страницы и ее содержимое. HTML-теги должны быть понятными для поисковика — это повышает сайт в выдаче по ключевому запросу. <br><br><b>2.Понятного человеческого  URL.</b>ЧПУ расшифровывается как человекопонятный URL. Под ним подразумевается URL-путь, который состоит из понятных слов. Он должен отражать структуру файлов сайта. Вместо  /c65/4/97/ должно быть /korol-anglijskogo-repa-mf-doom/.<br><br><b>3.Навигационной цепочки.</b>Они же хлебные крошки. Представляют собой цепочку из ссылок, по которой пользователи могут перемещаться по сайту — от главной страницы до определенной рубрики. Цепочки навигации — один из способов связывания страниц сайта между собой с помощью гиперссылок. <br><br><b>4.Robots.txt</b> — стандарты для поисковых роботов из разряда: “Здесь можно смотреть, а тут нельзя”. Можно ограничить доступ к контенту на http-сервере, если добавить текстовый файл robots.txt.<br><br><b>5.Ошибок 404.</b> Такие ошибки являются кодом ответа сервера. Они появляются, когда браузер не смог обнаружить на серверах указанный URL. То есть, вы зашли на сайт, но страница была удалена. Либо у вас к ней по каким-то причинам нет доступа.<br><br><b>6.Удаления дублей.</b> Страницы-дубли — это страницы, которые имеют разный адрес, но контент на них либо полностью, либо наполовину совпадает.  Дубли страниц мешают сайту полноценно индексироваться в поисковой системе. Все критерии, тонкости, сложные аббревиатуры… Они необходимы, чтобы ваш сайт был в ТОПе поисковой выдачи. Чем больше юзеров перешло на ваш сайт, тем выше вероятность, что на вашем сайте произойдет активное действие — покупка товаров или услуг.  Давайте проведем логическую цепочку. Нет SEO — нет хорошей поисковой выдачи. Нет поисковой выдачи — нет пользователей. Нет пользователей — нет монетизации. Нет монетизации — нет денег. Все просто!"  
  },

  {  
    "parent": "БЭМ",
    "title": "БЭМ",
    "text": "<b>БЭМ</b> (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке, в основе которого лежит принцип разделения интерфейса на независимые блоки.<br><br>Чтобы ускорить разработку, необходимо было облегчить поддержку HTML и CSS отдельных компонентов страницы, сделать код менее связанным. Для этого мы разбили страницу на части. Так появилось новое понятие — блок. Блок мог состоять из различных элементов, которые не использовались вне самого блока. Состояния и поведение блока и элемента можно было задавать с помощью модификатора.<br><br>Это были три ключевых понятия, на которых основывалось большинство правил. Аббревиатура от трех слов Блок, Элемент и Модификатор стала названием методологии — БЭМ.<br><br><b>Блок</b></><br>Логически и функционально независимый компонент страницы. Блок полностью самодостаточен. Блоки могут использоваться в любом месте страницы, повторно, даже в другом проекте.<br><br><b>Элемент</b><br>Часть блока, которая не может использоваться в отрыве от него и имеет смысл только в рамках своего родителя. Элементы могут быть обязательными и опциональными.<br><br><b>Модификатор</b><br>Свойство блока или элемента, которое меняет их внешний вид, состояние или поведение.<br>Модификатор имеет имя и может иметь значение. Использование модификаторов опционально.У блока/элемента может быть несколько разных модификаторов одновременно.<br>Элемент отделяется от блока двумя подчеркиваниями (__). Модификатор — одним (_).<br>Пример:<br><b>•Имя блока</b> — header.<br><br><b>•Имя элемента блока</b> — header__search-form — элемент search-form блока header<br><br><b>•Имя модификатора блока</b> — header_theme_green-forest — модификатор theme в значении green-forest блока header.<br><br><b>•Имя модификатора элемента</b> — header__search-form_disabled — булев модификатор disabled элемента search-form блока header."  
  },

  {  
    "parent": "Блочная модель",
    "title": "Блочная модель",
    "text": "<b>Блочная модель CSS</b> — это алгоритм расчёта размеров каждого отдельного элемента на странице, которым браузеры пользуются при отрисовке.  <br><br>Блочная модель состоит из четырёх частей:  <br><b>Содержимое (content)</b> - Область, в которой отображается фактическое содержимое элемента (например, текст, изображения). <br><br><b>Внутренний отступ (padding)</b> - Пространство между содержимым и границей.<br><br><b>Рамка (border)</b> - Линия, которая окружает содержимое и отступы. <br><br><b>Внешний отступ (margin)</b> - Пространство между границей и соседними элементами. <br><br>По умолчанию для блочной модели свойство box-sizing установлено в значение <b>content-box</b>, что означает, что размер элемента определяется размером его содержимого. <br>Изменив значение на <b>border-box</b>, можно изменить алгоритм расчёта таким образом, чтобы он включал отступы и границы в общий размер блочного элемента."  
  },

  {  
    "parent": "Медиа-запросы",
    "title": "Медиа-запросы",
    "text": "<b>Медиа-запросы (media queries)</b> – это правила CSS, которые позволяют управлять стилями элементов в зависимости от значений технических параметров устройств.<br><br>В <b>@media</b> можно указывать <b>определённые типы устройств: </b><br><b>all</b> – для всех;<br><b>print</b> – для принтеров и в режиме предварительного просмотра страницы перед печатью;<br><b>screen</b> – для устройств с экранами;•<br><b>speech</b> – для программ чтения с экрана.<br><br>Media Queries Level 4 – это четвертая редакция спецификации для <b>@media</b><br>В ней определён <u>новый и более простой синтаксис</u> для создания диапазона: <br><font color=\"red\"><b>*</b></font> Например: @media (992px <= width < 1200px) эквивалентно @media (min-width: 992px) and (max-width: 1199.98px)<br><br>Кроме этого, Media Queries Level 4 включает четыре медиа-функции, которые относятся к категории взаимодействия: pointer, any-pointer, hover и any-hover. С помощью них можно адаптировать сайты и веб-приложения для различных устройств в зависимости от наличия у них указателя, а также от того на сколько он точен.<br>Функция hover позволяет определить, может ли основное устройство ввода наводить курсор на элементы. Она принимает два значения: hover и none.<br>Термин <b>отзывчивый дизайн</b> сегодня отражает уже очень многое. У нас есть медиа-запросы, которые проверяют пользовательские настройки, а также современные возможности CSS, которые помогают создавать отзывчивые макеты вообще без использования медиа-запросов."  
  },

  {  
    "parent": "Flexbox",
    "title": "Flexbox",
    "text": "<b>Flexbox</b> (от англ. flex — гибкий) — это модуль CSS, который позволяет удобно управлять расположением, порядком, размерами и отступами между элементами веб-страницы. <br><br><b>Flexbox</b> состоит из гибкого контейнера (flex container) и гибких элементов (flex items). Гибкие элементы могут выстраиваться в строку или столбик, а оставшееся свободное пространство распределяется между ними различными способами.<br><br>Flexbox позволяет решать <b>следующие задачи:</b><br><b>1.</b> Располагать элементы в одном из четырёх направлений: слева направо, справа налево, сверху вниз или снизу вверх;  <br><b>2.</b> Переопределять порядок отображения элементов;  flex order. Элементы Flex с установленными на них бОльшими значениями order будут отображаться позже в порядке отображения, чем элементы с меньшими значениями порядка.<br><b>3.</b> Автоматически определять размеры элементов таким образом, чтобы они вписывались в доступное пространство;  <br><b>4.</b> Решать проблему с горизонтальным и вертикальным центрированием;  <br><b>5.</b> Переносить элементы внутри контейнера, не допуская его переполнения.  <br><br>Flexbox подходит для создания адаптивных веб-страниц, то есть сайтов, которые выглядят хорошо на разных устройствах: ПК, ноутбуках, планшетах и смартфонах.  <br><br>Вот некоторые свойства Flexbox:<br><br><b>flex-direction</b> - Определяет направление основной и поперечной осей в контейнере. Может принимать четыре значения: row (по умолчанию), row-reverse, column и column-reverse.  <br><br><b>flex-wrap</b> - Определяет, будут ли flex-элементы переноситься на другую строку, если им не хватит места в ряду. Может принимать одно из трёх значений: nowrap (по умолчанию), wrap и wrap-reverse.  <br><br><b>flex-flow</b> - Объединяет в одно свойство flex-direction и flex-wrap, позволяя задать их значения в одной строке.  <br><br><b>justify-content</b> - Определяет, как будут распределены элементы вдоль главной оси. Имеет 10 значений, но стабильно во всех браузерах работают следующие: flex-start, flex-end, center, space-between, space-around и space-evenly.  <br><br><b>align-items</b> - Выравнивает содержимое контейнера вдоль по поперечной оси. У свойства есть пять возможных значений: flex-start, flex-end, center, baseline и stretch.  <br><br><b>order</b> -Устанавливает порядок расположения элементов во flex-контейнере относительно друг друга. В качестве значения order принимает любое целое число: чем оно меньше, тем ближе к началу главной оси будет расположен элемент."  
  },

  {  
    "parent": "CSS-Grid",
    "title": "CSS-Grid",
    "text": "<b>Grid Layout</b> — это модуль CSS, который определяет систему макета на основе двумерной сетки. Она оптимизирована для дизайна пользовательского интерфейса. <br><br><b>Главная идея Grid Layout</b> — разделение веб-страницы на столбцы и строки. В образовавшиеся области сетки можно помещать элементы, а управлять их размерами и расположением можно с помощью специальных свойств модуля.  <br><br>Вот некоторые <b>свойства Grid Layout</b>:<br><br>1. <b>grid-template-columns</b> — определяет количество и ширину колонок.<br><br>2. <b>grid-template-rows</b> — определяет количество и высоту строк.<br><br>3. <b>gap</b> — задает расстояние между ячейками.<br><br>4. <b>grid-column-start / grid-column-end</b> — определяет, где начинается и заканчивается элемент по горизонтали.<br><br>5. <b>grid-row-start / grid-row-end — определяет</b>, где начинается и заканчивается элемент по вертикали.<br><br>6. <b>grid-template-areas</b> — позволяет именовать области сетки и размещать элементы в этих областях."  
  },

  {  
    "parent": "Позиционирование",
    "title": "Позиционирование",
    "text": "Позиционирование в CSS осуществляется с помощью свойства <b>position</b>, которое определяет, где находится элемент на веб-странице.<br><br>Значения свойства position:<br><b>static</b> - Значение по умолчанию, элемент позиционируется в соответствии с его местом в потоке документа.<br><br><b>relative</b> - Элемент позиционируется относительно своего исходного положения в потоке документа.<br><br><b>absolute</b> - Элемент позиционируется относительно ближайшего родительского элемента, который имеет позиционирование, отличное от static.  <br><br><b>fixed</b> - Элемент позиционируется относительно окна браузера.  <br><br><b>sticky</b> - Элемент остаётся на месте при прокрутке страницы, но при этом может быть отодвинут от своей стандартной позиции.<br><br>Также существуют дополнительные свойства CSS, которые позволяют сдвинуть элемент как по горизонтальной оси (left и right), так и по вертикальной (top и bottom):<br><b>top</b> - Сдвигает элемент вниз.  <br><b>right</b> - Сдвигает элемент влево.<br><b>bottom</b> - Сдвигает элемент вверх."  
  },

  {  
    "parent": "Отображение",
    "title": "Отображение",
    "text": "Свойство <b>display</b> в CSS используется для настройки отображения элемента.Оно управляет и изменяет способ отображения элементов HTML на веб-странице.<br><br>Свойство display определяет внешние и внутренние значения отображения элемента:<br><b>1.Внешнее значение отображения</b> определяет, будет ли бокс элемента занимать всю ширину родительского контейнера или его размер будет определяться содержимым.<br><br><b>2.Внутреннее значение отображения</b> управляет расположением дочерних элементов — будут ли они придерживаться обычного потока или следовать другим параметрам расположения.<br><br>Некоторые <b>значения свойства display</b>:<br><br><b>•Inline</b> - Используется для отображения строчного элемента. Строковые элементы отображаются в одну строку, то есть горизонтально, и занимают столько ширины, сколько необходимо.<br><br><b>•Block</b> - Элемент заполняет всю ширину своего контейнера. Каждый новый элемент отображается на новой строке, если не указано иное.<br><br><b>•None</b> - Используется для отключения отображения элемента. Элемент будет отображаться так, как будто был фактически удалён и никогда не существовал."  
  },

  {  
    "parent": "SCSS",
    "title": "SCSS",
    "text": "<b>SCSS</b> — это синтаксис препроцессорного скриптового языка Sass, основанный на стандартном для CSS синтаксисе.<br><br>SCSS даёт дополнительные возможности для написания CSS-кода: <br><b>1. Вложенность селекторов</b><br><b>2. Использование переменных</b> - <b>$</b>link: #15157d;<br><b>3. Вложенные селекторы и медиазапросы; </b><br><b>4. Сбор нескольких файлов в один</b><br><b>5. Миксины</b>  - @mixin(примеси) ― это многократно используемый блок SCSS-кода.<br><b>6. Наследование</b> - <br>Это одна из самых полезных функций Sass. Используя директиву <b>@extend</b> можно наследовать наборы свойств CSS от одного селектора другому. Это позволяет держать ваш Sass-файл в «чистоте».<br><br>SCSS не подключается в браузер напрямую. Он компилируется (собирается) в привычный для браузера CSS-код, и уже CSS-файл подключается на страницу."  
  },

  {  
    "parent": "Типы данных",
    "title": "Типы данных",
    "text": "<b>1. Number</b>(infinity, NaN – вычислительная ошибка)<br><br><b>2. String</b><br><br><b>3. Boolean</b> (логический тип)<br><br><b>4. Null</b> (ничего, пусто, значение не известно)<br><br><b>5. Undefined</b> (значение не присвоено)<br><br><b>6. Обьекты</b> (не примитивный тип данных, храним коллекции данных)<br><br><b>7. Symbol</b> — это примитивный, неизменяемый тип данных в JavaScript.<br><br>Символы представляют собой уникальные идентификаторы..Для создания символа можно использовать встроенную функцию Symbol ().<br><br><b>8. Bigint</b> - это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.<br>Чтобы создать значение типа BigInt, необходимо добавить <b>n</b> в конец числового литерала или вызвать функцию BigInt, которая создаст число типа BigInt из переданного аргумента. Аргументом может быть число, строка и др.<br><br><b>В чем отличие ссылочных типов от примитивных?</b><br>Основное различие между примитивными и ссылочными типами в JavaScript заключается в следующем:<br><b>1. Примитивные типы</b> хранятся как простые типы данных. Когда вы присваиваете примитивное значение переменной, значение копируется в эту переменную.<br><b>2. Ссылочные типы данных</b>, они же – объекты (объекты, массивы и функции), это области памяти неопределенного размера и доступные по идентификатору.Они содержат ссылку на местоположение в памяти."  
  },

  {  
    "parent": "Преобразование типов",
    "title": "Преобразование типов",
    "text": "Преобразование может быть <b>явным</b> и <b>неявным</b>: <br><br><b>Явное преобразование</b> - Разработчик явно указывает в коде программы преобразование типов, например, с помощью функций Number() или String().<br><b>Неявное преобразование</b> - Происходит автоматически в процессе выполнения операций. Обычно такое случается, когда в выражениях используют значения различных типов или в зависимости от контекста выражения.<br><br><b>1. Строковое преобразование</b> - преобразование происходит очевидным образом. false становится \"false\", null становится \"null\" и т.п. String(value)<br><br><b>2. Численное преобразование </b>происходит в математических функциях и выражениях.<br>Например, когда операция деления / применяется не к числу.<br><u>Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN.</u><br><br>Мы можем использовать функцию <b>Number(value) </b> или <b>+</b>, чтобы явно преобразовать value к числу.<br><br><b>Правила численного преобразования</b>:<br>Undefined преобразуется в NaN<br>null преобразуется в 0<br>true / false преобразуется в 1 / 0<br>string - Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.<br><br><b>3. Логическое преобразование</b> – Интуитивно пустые значения 0, Null, undefined, NaN, пустая строка преобразуются в false,<br>Все остальные становятся true"  
  },

  {  
    "parent": "VAR, LET и CONST",
    "title": "VAR, LET и CONST",
    "text": "Переменные, объявленные при помощи <b>var</b>, имеют <b>глобальную</b>,  или <b> локальную (в рамках функции) </b>,  область видимости.<br><br> Если вы объявляете переменные с использованием <b>let</b> или <b>const</b>, их область видимости будет <b>блочной</b>.<br><br> Переменные, объявленные при помощи <b><u>var</u>, могут обновляться и объявляться заново</b>.<br><br> <b>Использование <u>let</u> позволяет обновлять переменную, но не объявлять заново</b>, а использование <b><u>const</u> не предполагает ни того, ни другого.</b><br><br> Переменные всех видов поднимаются в верх своей области видимости. Но переменные, объявленные при помощи <u>var</u>, инициализируются как <u>undefined</u>, а объявленные с использованием <u>let</u> или <u>const</u> — не инициализируются.<br><br> <b>При помощи var или let</b> можно объявлять переменные без их инициализации, но если вы объявляете переменную при помощи <b>const</b>, она должна инициализироваться при объявлении.<br><br><font color=\"red\"><b>*</b></font> Переменные, созданные в глобальной области видимости с помощью ключевых слов let, const и class, не являются свойствами глобального объекта."  
  },

  {  
    "parent": "Области видимости",
    "title": "Области видимости",
    "text": "<b> Область видимости</b>  в JavaScript — <b>Концепция, которая определяет границы действия переменных.</b><br><br>Область видимости решает проблему хаоса в коде. Без неё, все переменные были бы доступны везде, что приводило бы к ошибкам и конфликтам.<br> <br> Она может быть:<br> <b> Глобальная</b> Элементы программы открыты для использования в любой её части. Они объявляются за рамками функций и блоков.<br> <br> <b> Локальная</b> Элементы доступны только в определённом блоке или функции. Это помогает избежать конфликтов между элементами, объявленными в разных частях программы.<br> Локальную область видимости можно разбить на два типа:<br> <b> Функциональная</b> Зона видимости элементов, объявленных внутри функции.<br><b> Блочная</b> Зона видимости переменных, объявленных внутри блока кода."  
  },

  {  
    "parent": "Контекст и ключевое слово this",
    "title": "Контекст и ключевое слово this",
    "text": "Кроме области видимости в JavaScript имеется ещё <b>контекст</b> (context). <br><b>Контекст</b> – это то, на что указывает <b>this</b>.<br>По сути <b>this</b>– это объект, которому «принадлежит» выполняемый в данный момент код.<br><br><b>1.</b> В контексте глобального объекта (вне модулей и функций) <b>this</b>– это глобальный объект.<br><br><b>2.</b> Внутри функции <b>this</b> зависит от того, как вызывается функция:<br><br>2.1. Если функция вызывается не как метод объекта, то <b>this</b> в не строгом режиме указывает на глобальный объект, а в строгом – <b>undefined</b>.<br><br>2.2. Когда функция вызывается как метод, <b>this</b>– это объект, который использовался для его вызова<br><br><b>3.</b> Внутри класса <b>this</b> указывает на новый объект, который будет создан с помощью new:<br><br><b>4.</b> В модуле на верхнем уровне <b>this</b>– это <b>undefined</b>.<br><br><font color=\"red\"><b>*</b></font> <b>Стрелочные функции нет имеют собственного this</b>.<br>Если внутри стрелочной функции происходит обращение к <b>this</b>, она берёт его снаружи."  
  },

  {  
    "parent": "Call или Apply, Bind",
    "title": "Call или Apply, Bind",
    "text": "<h4>1.Указание контекста с помощью call или apply</h4><br>В JavaScript при вызове функции можно установить нужный this, т.е. контекст, в котором она должна выполняться. Осуществляется это с помощью <b>метода call</b> или <b>apply</b>.<br><br>Первым аргументом передаётся сам объект, следующими аргументами передаются параметры.<br><br><u>Синтаксис использования метода <b>call</b>:</u><br><br>Например:<br><b>объект user:</b><br>const user = {<br>&nbsp;&nbsp;name: 'Василий',<br>&nbsp;&nbsp;age: 27<br>}<br><b>объявление функции getAge:</b><br>const getAge = function() {<br> &nbsp;&nbsp;return this.age;<br>}<br><b>вызов функции в контексте объекта user:</b><br>console.log(getAge.call(user)); // 27<br><br><b>Метод apply</b> аналогичен call. Единственное отличие в том, что аргументы в <b>apply передаются в виде массива</b>.<br><br>В качестве thisArg методам call и apply, кроме объекта, можно также установить значение null или undefined. В не строгом режиме эти значения будут заменены ссылкой на глобальный объект. <br><br><font color=\"red\"><b>*</b></font> Call привязывает контекст и сразу же вызывает функцию.<br><br><br><br><h4>2.Метод bind</h4><br>Позволяет привязать функцию объекту в качестве метода (установить нужный this для функции), в отличие от call и apply позволяет не вызывать её сразу, а записать в переменную, чтобы использовать в дальнейшем.<br>Первым аргументом передаётся сам объект, следующими аргументами передаются параметры."  
  },

  {  
    "parent": "Контекст выполнения, Стек вызовов",
    "title": "Контекст выполнения, Стек вызовов",
    "text": "<font color=\"red\"><b>*</b></font> <b>Контекст выполнения</b> (execution context) — это, если говорить упрощённо, концепция, описывающая окружение, в котором производится выполнение кода на JavaScript. Код всегда выполняется внутри некоего контекста.<br><br><b><mark>Типы контекстов выполнения<mark></b><br><br>В JavaScript существует <b>три типа контекстов выполнения</b>:<br><b>• Глобальный контекст выполнения</b> - Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект window, и тем, что ключевое слово this указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.<br><br><b>• Контекст выполнения функции</b> -  Каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждая функция имеет собственный контекст выполнения. В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.<br><br><b>• Контекст выполнения функции eval</b> -  Код, выполняемый внутри функции eval, также имеет собственный контекст выполнения. Однако функцией eval пользуются очень редко, поэтому здесь мы об этом контексте выполнения говорить не будем. <br><br><br><h4><b>Стек вызовов</b></h4><br><font color=\"red\"><b>*</b></font> <b>Стек выполнения</b> (execution stack), который ещё называют <b>стеком вызовов</b> (call stack), это LIFO-стек, который используется для хранения контекстов выполнения, создаваемых в ходе работы кода.<br><br>Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения и помещает его в текущий стек. При обнаружении команды вызова функции движок создаёт новый контекст выполнения для этой функции и помещает его в верхнюю часть стека.<br><br>Движок выполняет функцию, контекст выполнения которой находится в верхней части стека. Когда работа функции завершается, её контекст извлекается из стека и управление передаётся тому контексту, который находится в предыдущем элементе стека."  
  }
]
 