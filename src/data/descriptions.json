[
  {  
    "parent": "Семантические элементы",
    "title": "Семантические элементы",
    "text": "<b>Семантические элементы HTML</b> — это теги, которые явно описывают содержимое веб-страницы.<br><br>Некоторые распространённые семантические элементы и их назначение:<br><br><b>header</b> используется для выделения верхней части веб-страницы, которая содержит заголовок или логотип, навигационные ссылки и другие элементы, общие для всех страниц сайта<br><br><b>nav</b>  Обозначает раздел веб-страницы, содержащий навигационные ссылки.<br><br><b>main</b> Выделяет основную часть содержимого веб-страницы.<br><br><b>article</b> Используется для обозначения самостоятельного содержимого, которое может быть независимо распространено или повторно использовано.<br><br><b>section</b> Определяет разделы документа, такие как главы, части или другие логические группы контента<br><br><b>aside</b> Тег для дополнительного контента, используется для создания сайдбара или бокового меню на сайтах.<br><br><b>footer</b> Тег с информацией о разделе. Например, это могут быть данные о том, когда была написана статья, её авторе и пр.<br><br>Семантические элементы помогают создать структурированную и понятную веб-страницу, что улучшает пользовательский опыт и SEO (поисковую оптимизацию)."
  },

  {  
    "parent": "Формы и валидация",
    "title": "Формы и валидация",
    "text": "Примеры атрибутов для валидации:<br><br><b>required</b> – проверка обязательных полей<br><br><b>maxlength</b> – ограничение на количество символов<br><br><b>max, min</b> - диапазон между максимумом и минимумом<br><br><b>pattern</b> - Атрибут паттерн использует регулярное выражение для валидаций этого поля."
  },

  {  
    "parent": "Кроссбраузерная вёрстка",
    "title": "Кроссбраузерная вёрстка",
    "text": "Чтобы сделать сайт кроссбраузерным, можно предпринять следующие шаги:<br><br><b>1.Применить CSS-хаки.<br></b>Это элементы кода, которые понимает только один браузер.Они помогают настроить отображение элементов ресурса под каждую программу.<br><br><b>2.Использовать вендорные префиксы.<br></b>В каждом браузере есть свои вендорные префиксы и уникальные свойства. Например, в Mozilla Firefox это свойство moz-border-radius, в Safari и Chrome — webkit-border-radius. Они способны менять поведение элемента, не влияя на другие браузеры.<br><br><b>3.Ввести универсальные элементы.<br></b> Они эффективно работают в подавляющем большинстве браузеров.Если использовать только их, то код будет понятным, эстетичным и чистым.Проверить, какие элементы поддерживают разные браузеры, можно в сервисе caniuse.com.<br><br>4.Для проверки кроссбраузерности сайта можно использовать <b>специальные сервисы</b>, например: CrossBrowserTesting, MultiBrowser, Litmus, Equafy, Sauce Labs."
    
  },

  {  
    "parent": "Основы SEO",
    "title": "Основы SEO",
    "text": "SEO-база состоит из:<br><b>1.Метатегов.</b> Они же HTML-теги. Их предназначение — предоставление структурированной информации о странице веб-сайта. Метатеги — помощники поисковых роботов, которые дают им возможность распознать тематику страницы и ее содержимое. HTML-теги должны быть понятными для поисковика — это повышает сайт в выдаче по ключевому запросу. <br><br><b>2.Понятного человеческого  URL.</b>ЧПУ расшифровывается как человекопонятный URL. Под ним подразумевается URL-путь, который состоит из понятных слов. Он должен отражать структуру файлов сайта. Вместо  /c65/4/97/ должно быть /korol-anglijskogo-repa-mf-doom/.<br><br><b>3.Навигационной цепочки.</b>Они же хлебные крошки. Представляют собой цепочку из ссылок, по которой пользователи могут перемещаться по сайту — от главной страницы до определенной рубрики. Цепочки навигации — один из способов связывания страниц сайта между собой с помощью гиперссылок. <br><br><b>4.Robots.txt</b> — стандарты для поисковых роботов из разряда: “Здесь можно смотреть, а тут нельзя”. Можно ограничить доступ к контенту на http-сервере, если добавить текстовый файл robots.txt.<br><br><b>5.Ошибок 404.</b> Такие ошибки являются кодом ответа сервера. Они появляются, когда браузер не смог обнаружить на серверах указанный URL. То есть, вы зашли на сайт, но страница была удалена. Либо у вас к ней по каким-то причинам нет доступа.<br><br><b>6.Удаления дублей.</b> Страницы-дубли — это страницы, которые имеют разный адрес, но контент на них либо полностью, либо наполовину совпадает.  Дубли страниц мешают сайту полноценно индексироваться в поисковой системе. Все критерии, тонкости, сложные аббревиатуры… Они необходимы, чтобы ваш сайт был в ТОПе поисковой выдачи. Чем больше юзеров перешло на ваш сайт, тем выше вероятность, что на вашем сайте произойдет активное действие — покупка товаров или услуг.  Давайте проведем логическую цепочку. Нет SEO — нет хорошей поисковой выдачи. Нет поисковой выдачи — нет пользователей. Нет пользователей — нет монетизации. Нет монетизации — нет денег. Все просто!"  
  },

  {  
    "parent": "БЭМ",
    "title": "БЭМ",
    "text": "<b>БЭМ</b> (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке, в основе которого лежит принцип разделения интерфейса на независимые блоки.<br><br>Чтобы ускорить разработку, необходимо было облегчить поддержку HTML и CSS отдельных компонентов страницы, сделать код менее связанным. Для этого мы разбили страницу на части. Так появилось новое понятие — блок. Блок мог состоять из различных элементов, которые не использовались вне самого блока. Состояния и поведение блока и элемента можно было задавать с помощью модификатора.<br><br>Это были три ключевых понятия, на которых основывалось большинство правил. Аббревиатура от трех слов Блок, Элемент и Модификатор стала названием методологии — БЭМ.<br><br><b>Блок</b></><br>Логически и функционально независимый компонент страницы. Блок полностью самодостаточен. Блоки могут использоваться в любом месте страницы, повторно, даже в другом проекте.<br><br><b>Элемент</b><br>Часть блока, которая не может использоваться в отрыве от него и имеет смысл только в рамках своего родителя. Элементы могут быть обязательными и опциональными.<br><br><b>Модификатор</b><br>Свойство блока или элемента, которое меняет их внешний вид, состояние или поведение.<br>Модификатор имеет имя и может иметь значение. Использование модификаторов опционально.У блока/элемента может быть несколько разных модификаторов одновременно.<br>Элемент отделяется от блока двумя подчеркиваниями (__). Модификатор — одним (_).<br>Пример:<br><b>•Имя блока</b> — header.<br><br><b>•Имя элемента блока</b> — header__search-form — элемент search-form блока header<br><br><b>•Имя модификатора блока</b> — header_theme_green-forest — модификатор theme в значении green-forest блока header.<br><br><b>•Имя модификатора элемента</b> — header__search-form_disabled — булев модификатор disabled элемента search-form блока header."  
  },

  {  
    "parent": "Блочная модель",
    "title": "Блочная модель",
    "text": "<b>Блочная модель CSS</b> — это алгоритм расчёта размеров каждого отдельного элемента на странице, которым браузеры пользуются при отрисовке.  <br><br>Блочная модель состоит из четырёх частей:  <br><b>Содержимое (content)</b> - Область, в которой отображается фактическое содержимое элемента (например, текст, изображения). <br><br><b>Внутренний отступ (padding)</b> - Пространство между содержимым и границей.<br><br><b>Рамка (border)</b> - Линия, которая окружает содержимое и отступы. <br><br><b>Внешний отступ (margin)</b> - Пространство между границей и соседними элементами. <br><br>По умолчанию для блочной модели свойство box-sizing установлено в значение <b>content-box</b>, что означает, что размер элемента определяется размером его содержимого. <br>Изменив значение на <b>border-box</b>, можно изменить алгоритм расчёта таким образом, чтобы он включал отступы и границы в общий размер блочного элемента."  
  },

  {  
    "parent": "Медиа-запросы",
    "title": "Медиа-запросы",
    "text": "<b>Медиа-запросы (media queries)</b> – это правила CSS, которые позволяют управлять стилями элементов в зависимости от значений технических параметров устройств.<br><br>В <b>@media</b> можно указывать <b>определённые типы устройств: </b><br><b>all</b> – для всех;<br><b>print</b> – для принтеров и в режиме предварительного просмотра страницы перед печатью;<br><b>screen</b> – для устройств с экранами;•<br><b>speech</b> – для программ чтения с экрана.<br><br>Media Queries Level 4 – это четвертая редакция спецификации для <b>@media</b><br>В ней определён <u>новый и более простой синтаксис</u> для создания диапазона: <br><font color=\"red\"><b>*</b></font> Например: @media (992px <= width < 1200px) эквивалентно @media (min-width: 992px) and (max-width: 1199.98px)<br><br>Кроме этого, Media Queries Level 4 включает четыре медиа-функции, которые относятся к категории взаимодействия: pointer, any-pointer, hover и any-hover. С помощью них можно адаптировать сайты и веб-приложения для различных устройств в зависимости от наличия у них указателя, а также от того на сколько он точен.<br>Функция hover позволяет определить, может ли основное устройство ввода наводить курсор на элементы. Она принимает два значения: hover и none.<br>Термин <b>отзывчивый дизайн</b> сегодня отражает уже очень многое. У нас есть медиа-запросы, которые проверяют пользовательские настройки, а также современные возможности CSS, которые помогают создавать отзывчивые макеты вообще без использования медиа-запросов."  
  },

  {  
    "parent": "Flexbox",
    "title": "Flexbox",
    "text": "<b>Flexbox</b> (от англ. flex — гибкий) — это модуль CSS, который позволяет удобно управлять расположением, порядком, размерами и отступами между элементами веб-страницы. <br><br><b>Flexbox</b> состоит из гибкого контейнера (flex container) и гибких элементов (flex items). Гибкие элементы могут выстраиваться в строку или столбик, а оставшееся свободное пространство распределяется между ними различными способами.<br><br>Flexbox позволяет решать <b>следующие задачи:</b><br><b>1.</b> Располагать элементы в одном из четырёх направлений: слева направо, справа налево, сверху вниз или снизу вверх;  <br><b>2.</b> Переопределять порядок отображения элементов;  flex order. Элементы Flex с установленными на них бОльшими значениями order будут отображаться позже в порядке отображения, чем элементы с меньшими значениями порядка.<br><b>3.</b> Автоматически определять размеры элементов таким образом, чтобы они вписывались в доступное пространство;  <br><b>4.</b> Решать проблему с горизонтальным и вертикальным центрированием;  <br><b>5.</b> Переносить элементы внутри контейнера, не допуская его переполнения.  <br><br>Flexbox подходит для создания адаптивных веб-страниц, то есть сайтов, которые выглядят хорошо на разных устройствах: ПК, ноутбуках, планшетах и смартфонах.  <br><br>Вот некоторые свойства Flexbox:<br><br><b>flex-direction</b> - Определяет направление основной и поперечной осей в контейнере. Может принимать четыре значения: row (по умолчанию), row-reverse, column и column-reverse.  <br><br><b>flex-wrap</b> - Определяет, будут ли flex-элементы переноситься на другую строку, если им не хватит места в ряду. Может принимать одно из трёх значений: nowrap (по умолчанию), wrap и wrap-reverse.  <br><br><b>flex-flow</b> - Объединяет в одно свойство flex-direction и flex-wrap, позволяя задать их значения в одной строке.  <br><br><b>justify-content</b> - Определяет, как будут распределены элементы вдоль главной оси. Имеет 10 значений, но стабильно во всех браузерах работают следующие: flex-start, flex-end, center, space-between, space-around и space-evenly.  <br><br><b>align-items</b> - Выравнивает содержимое контейнера вдоль по поперечной оси. У свойства есть пять возможных значений: flex-start, flex-end, center, baseline и stretch.  <br><br><b>order</b> -Устанавливает порядок расположения элементов во flex-контейнере относительно друг друга. В качестве значения order принимает любое целое число: чем оно меньше, тем ближе к началу главной оси будет расположен элемент."  
  },

  {  
    "parent": "CSS-Grid",
    "title": "CSS-Grid",
    "text": "<b>Grid Layout</b> — это модуль CSS, который определяет систему макета на основе двумерной сетки. Она оптимизирована для дизайна пользовательского интерфейса. <br><br><b>Главная идея Grid Layout</b> — разделение веб-страницы на столбцы и строки. В образовавшиеся области сетки можно помещать элементы, а управлять их размерами и расположением можно с помощью специальных свойств модуля.  <br><br>Вот некоторые <b>свойства Grid Layout</b>:<br><br>1. <b>grid-template-columns</b> — определяет количество и ширину колонок.<br><br>2. <b>grid-template-rows</b> — определяет количество и высоту строк.<br><br>3. <b>gap</b> — задает расстояние между ячейками.<br><br>4. <b>grid-column-start / grid-column-end</b> — определяет, где начинается и заканчивается элемент по горизонтали.<br><br>5. <b>grid-row-start / grid-row-end — определяет</b>, где начинается и заканчивается элемент по вертикали.<br><br>6. <b>grid-template-areas</b> — позволяет именовать области сетки и размещать элементы в этих областях."  
  },

  {  
    "parent": "Позиционирование",
    "title": "Позиционирование",
    "text": "Позиционирование в CSS осуществляется с помощью свойства <b>position</b>, которое определяет, где находится элемент на веб-странице.<br><br>Значения свойства position:<br><b>static</b> - Значение по умолчанию, элемент позиционируется в соответствии с его местом в потоке документа.<br><br><b>relative</b> - Элемент позиционируется относительно своего исходного положения в потоке документа.<br><br><b>absolute</b> - Элемент позиционируется относительно ближайшего родительского элемента, который имеет позиционирование, отличное от static.  <br><br><b>fixed</b> - Элемент позиционируется относительно окна браузера.  <br><br><b>sticky</b> - Элемент остаётся на месте при прокрутке страницы, но при этом может быть отодвинут от своей стандартной позиции.<br><br>Также существуют дополнительные свойства CSS, которые позволяют сдвинуть элемент как по горизонтальной оси (left и right), так и по вертикальной (top и bottom):<br><b>top</b> - Сдвигает элемент вниз.  <br><b>right</b> - Сдвигает элемент влево.<br><b>bottom</b> - Сдвигает элемент вверх."  
  },

  {  
    "parent": "Отображение",
    "title": "Отображение",
    "text": "Свойство <b>display</b> в CSS используется для настройки отображения элемента.Оно управляет и изменяет способ отображения элементов HTML на веб-странице.<br><br>Свойство display определяет внешние и внутренние значения отображения элемента:<br><b>1.Внешнее значение отображения</b> определяет, будет ли бокс элемента занимать всю ширину родительского контейнера или его размер будет определяться содержимым.<br><br><b>2.Внутреннее значение отображения</b> управляет расположением дочерних элементов — будут ли они придерживаться обычного потока или следовать другим параметрам расположения.<br><br>Некоторые <b>значения свойства display</b>:<br><br><b>•Inline</b> - Используется для отображения строчного элемента. Строковые элементы отображаются в одну строку, то есть горизонтально, и занимают столько ширины, сколько необходимо.<br><br><b>•Block</b> - Элемент заполняет всю ширину своего контейнера. Каждый новый элемент отображается на новой строке, если не указано иное.<br><br><b>•None</b> - Используется для отключения отображения элемента. Элемент будет отображаться так, как будто был фактически удалён и никогда не существовал."  
  },

  {  
    "parent": "SCSS",
    "title": "SCSS",
    "text": "<b>SCSS</b> — это синтаксис препроцессорного скриптового языка Sass, основанный на стандартном для CSS синтаксисе.<br><br>SCSS даёт дополнительные возможности для написания CSS-кода: <br><b>1. Вложенность селекторов</b><br><b>2. Использование переменных</b> - <b>$</b>link: #15157d;<br><b>3. Вложенные селекторы и медиазапросы; </b><br><b>4. Сбор нескольких файлов в один</b><br><b>5. Миксины</b>  - @mixin(примеси) ― это многократно используемый блок SCSS-кода.<br><b>6. Наследование</b> - <br>Это одна из самых полезных функций Sass. Используя директиву <b>@extend</b> можно наследовать наборы свойств CSS от одного селектора другому. Это позволяет держать ваш Sass-файл в «чистоте».<br><br>SCSS не подключается в браузер напрямую. Он компилируется (собирается) в привычный для браузера CSS-код, и уже CSS-файл подключается на страницу."  
  },

  {  
    "parent": "Типы данных",
    "title": "Типы данных",
    "text": "<b>1. Number</b>(infinity, NaN – вычислительная ошибка)<br><br><b>2. String</b><br><br><b>3. Boolean</b> (логический тип)<br><br><b>4. Null</b> (ничего, пусто, значение не известно)<br><br><b>5. Undefined</b> (значение не присвоено)<br><br><b>6. Обьекты</b> (не примитивный тип данных, храним коллекции данных)<br><br><b>7. Symbol</b> — это примитивный, неизменяемый тип данных в JavaScript.<br><br>Символы представляют собой уникальные идентификаторы..Для создания символа можно использовать встроенную функцию Symbol ().<br><br><b>8. Bigint</b> - это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.<br>Чтобы создать значение типа BigInt, необходимо добавить <b>n</b> в конец числового литерала или вызвать функцию BigInt, которая создаст число типа BigInt из переданного аргумента. Аргументом может быть число, строка и др.<br><br><b>В чем отличие ссылочных типов от примитивных?</b><br>Основное различие между примитивными и ссылочными типами в JavaScript заключается в следующем:<br><b>1. Примитивные типы</b> хранятся как простые типы данных. Когда вы присваиваете примитивное значение переменной, значение копируется в эту переменную.<br><b>2. Ссылочные типы данных</b>, они же – объекты (объекты, массивы и функции), это области памяти неопределенного размера и доступные по идентификатору.Они содержат ссылку на местоположение в памяти."  
  },

  {  
    "parent": "Преобразование типов",
    "title": "Преобразование типов",
    "text": "Преобразование может быть <b>явным</b> и <b>неявным</b>: <br><br><b><mark>В чем разница == и ===?</mark></b><br> <b>==</b> сравнивает значения с приведением типов, что может приводить к неожиданным результатам, тогда как <b>>===</b> сравнивает как значения, так и типы данных.<br>Это означает, что <b>===</b> является более строгим оператором и не выполняет автоматическое преобразование типов.<br> Например, 1 == '1' вернёт true, а 1 === '1' — false. <br><font color=\"red\"><b>*</b></font> Использование <b>===</b> более предпочтительно для избежания ошибок.<br><br><b><mark>Явное преобразование</mark></b> - Разработчик явно указывает в коде программы преобразование типов, например, с помощью функций Number() или String().<br><b><mark>Неявное преобразование</mark></b> - Происходит автоматически в процессе выполнения операций. Обычно такое случается, когда в выражениях используют значения различных типов или в зависимости от контекста выражения.<br><br><b><mark>1. Строковое преобразование</mark></b> - преобразование происходит очевидным образом. false становится \"false\", null становится \"null\" и т.п. String(value)<br><br><b><mark>2. Численное преобразование<mark></b>происходит в математических функциях и выражениях.<br>Например, когда операция деления / применяется не к числу.<br><u>Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN.</u><br><br>Мы можем использовать функцию <b>Number(value) </b> или <b>+</b>, чтобы явно преобразовать value к числу.<br><br><b><mark>Правила численного преобразования</mark></b>:<br><font color=\"red\">Undefined</font> преобразуется в <font color=\"red\">NaN</font><br><font color=\"red\">null</font> преобразуется в <font color=\"red\">0</font><br><font color=\"red\">true / false</font> преобразуется в <font color=\"red\">1 / 0</font><br><font color=\"red\">string</font> - Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, <font color=\"red\">если остаётся пустая строка</font>, то получаем <font color=\"red\">0</font>, <font color=\"red\">иначе из непустой строки «считывается» число</font>. При ошибке результат <font color=\"red\">NaN</font>.<br><br><b><mark>3. Логическое преобразование</mark></b> – Интуитивно пустые значения 0, Null, undefined, NaN, пустая строка преобразуются в false,<br>Все остальные становятся true"  
  },

  {  
    "parent": "VAR, LET и CONST",
    "title": "VAR, LET и CONST",
    "text": "Переменные, объявленные при помощи <b>var</b>, имеют <b>глобальную</b>,  или <b> локальную (в рамках функции) </b>,  область видимости.<br><br> Если вы объявляете переменные с использованием <b>let</b> или <b>const</b>, их область видимости будет <b>блочной</b>.<br><br> Переменные, объявленные при помощи <b><u>var</u>, могут обновляться и объявляться заново</b>.<br><br> <b>Использование <u>let</u> позволяет обновлять переменную, но не объявлять заново</b>, а использование <b><u>const</u> не предполагает ни того, ни другого.</b><br><br> Переменные всех видов поднимаются в верх своей области видимости. Но переменные, объявленные при помощи <u>var</u>, инициализируются как <u>undefined</u>, а объявленные с использованием <u>let</u> или <u>const</u> — не инициализируются.<br><br> <b>При помощи var или let</b> можно объявлять переменные без их инициализации, но если вы объявляете переменную при помощи <b>const</b>, она должна инициализироваться при объявлении.<br><br><font color=\"red\"><b>*</b></font> Переменные, созданные в глобальной области видимости с помощью ключевых слов let, const и class, не являются свойствами глобального объекта."  
  },

  {  
    "parent": "Области видимости",
    "title": "Области видимости",
    "text": "<b> Область видимости</b>  в JavaScript — <b>Концепция, которая определяет границы действия переменных.</b><br><br>Область видимости решает проблему хаоса в коде. Без неё, все переменные были бы доступны везде, что приводило бы к ошибкам и конфликтам.<br> <br> Она может быть:<br> <b> Глобальная</b> Элементы программы открыты для использования в любой её части. Они объявляются за рамками функций и блоков.<br> <br> <b> Локальная</b> Элементы доступны только в определённом блоке или функции. Это помогает избежать конфликтов между элементами, объявленными в разных частях программы.<br> Локальную область видимости можно разбить на два типа:<br> <b> Функциональная</b> Зона видимости элементов, объявленных внутри функции.<br><b> Блочная</b> Зона видимости переменных, объявленных внутри блока кода."  
  },

  {  
    "parent": "Контекст и ключевое слово this",
    "title": "Контекст и ключевое слово this",
    "text": "Кроме области видимости в JavaScript имеется ещё <b>контекст</b> (context). <br><b>Контекст</b> – это то, на что указывает <b>this</b>.<br>По сути <b>this</b>– это объект, которому «принадлежит» выполняемый в данный момент код.<br><br><b>1.</b> В контексте глобального объекта (вне модулей и функций) <b>this</b>– это глобальный объект.<br><br><b>2.</b> Внутри функции <b>this</b> зависит от того, как вызывается функция:<br><br>2.1. Если функция вызывается не как метод объекта, то <b>this</b> в не строгом режиме указывает на глобальный объект, а в строгом – <b>undefined</b>.<br><br>2.2. Когда функция вызывается как метод, <b>this</b>– это объект, который использовался для его вызова<br><br><b>3.</b> Внутри класса <b>this</b> указывает на новый объект, который будет создан с помощью new:<br><br><b>4.</b> В модуле на верхнем уровне <b>this</b>– это <b>undefined</b>.<br><br><font color=\"red\"><b>*</b></font> <b>Стрелочные функции нет имеют собственного this</b>.<br>Если внутри стрелочной функции происходит обращение к <b>this</b>, она берёт его снаружи."  
  },

  {  
    "parent": "Call или Apply, Bind",
    "title": "Call или Apply, Bind",
    "text": "<h4>1.Указание контекста с помощью call или apply</h4><br>В JavaScript при вызове функции можно установить нужный this, т.е. контекст, в котором она должна выполняться. Осуществляется это с помощью <b>метода call</b> или <b>apply</b>.<br><br>Первым аргументом передаётся сам объект, следующими аргументами передаются параметры.<br><br><u>Синтаксис использования метода <b>call</b>:</u><br><br>Например:<br><b>объект user:</b><br>const user = {<br>&nbsp;&nbsp;name: 'Василий',<br>&nbsp;&nbsp;age: 27<br>}<br><b>объявление функции getAge:</b><br>const getAge = function() {<br> &nbsp;&nbsp;return this.age;<br>}<br><b>вызов функции в контексте объекта user:</b><br>console.log(getAge.call(user)); // 27<br><br><b>Метод apply</b> аналогичен call. Единственное отличие в том, что аргументы в <b>apply передаются в виде массива</b>.<br><br>В качестве thisArg методам call и apply, кроме объекта, можно также установить значение null или undefined. В не строгом режиме эти значения будут заменены ссылкой на глобальный объект. <br><br><font color=\"red\"><b>*</b></font> Call привязывает контекст и сразу же вызывает функцию.<br><br><br><br><h4>2.Метод bind</h4><br>Позволяет привязать функцию объекту в качестве метода (установить нужный this для функции), в отличие от call и apply позволяет не вызывать её сразу, а записать в переменную, чтобы использовать в дальнейшем.<br>Первым аргументом передаётся сам объект, следующими аргументами передаются параметры."  
  },

  {  
    "parent": "Контекст выполнения, Стек вызовов",
    "title": "Контекст выполнения, Стек вызовов",
    "text": "<font color=\"red\"><b>*</b></font> <b>Контекст выполнения</b> (execution context) — это, если говорить упрощённо, концепция, описывающая окружение, в котором производится выполнение кода на JavaScript. Код всегда выполняется внутри некоего контекста.<br><br><b><mark>Типы контекстов выполнения<mark></b><br><br>В JavaScript существует <b>три типа контекстов выполнения</b>:<br><b>• Глобальный контекст выполнения</b> - Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект window, и тем, что ключевое слово this указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.<br><br><b>• Контекст выполнения функции</b> -  Каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждая функция имеет собственный контекст выполнения. В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.<br><br><b>• Контекст выполнения функции eval</b> -  Код, выполняемый внутри функции eval, также имеет собственный контекст выполнения. Однако функцией eval пользуются очень редко, поэтому здесь мы об этом контексте выполнения говорить не будем. <br><br><br><h4><b>Стек вызовов</b></h4><br><font color=\"red\"><b>*</b></font> <b>Стек выполнения</b> (execution stack), который ещё называют <b>стеком вызовов</b> (call stack), это LIFO-стек, который используется для хранения контекстов выполнения, создаваемых в ходе работы кода.<br><br>Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения и помещает его в текущий стек. При обнаружении команды вызова функции движок создаёт новый контекст выполнения для этой функции и помещает его в верхнюю часть стека.<br><br>Движок выполняет функцию, контекст выполнения которой находится в верхней части стека. Когда работа функции завершается, её контекст извлекается из стека и управление передаётся тому контексту, который находится в предыдущем элементе стека."  
  },

  {  
    "parent": "Массивы",
    "title": "Массивы",
    "text": "<b>Массив</b>  – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.<br><br>Существует два варианта синтаксиса для создания пустого массива:<br><br>• let arr = new Array();<br>• let arr = [];<br><br>Cами массивы <b>являются перебираемыми объектами.</b> Но есть и много других встроенных перебираемых объектов, например, <u>строки</u>.<br><br>Свойство <u>length</u> отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.<br><br>Чтобы пройтись по элементам массива:<br><br><b>• for (let i=0;  I < arr.length;  i++)</b> – работает быстрее всего, совместим со старыми браузерами.<br><br><b>• for (let item of arr) </b>  – современный синтаксис только для значений элементов (к индексам нет доступа).<br><br><b>• for (let i in arr) </b>  – никогда не используйте для массивов.<br><br>Есть универсальный метод <b> Array.from</b> , который принимает итерируемый объект или псевдомассив и делает из него «настоящий» Array. После этого мы уже можем использовать методы массивов.<br><br><font color=\"red\"><b>*</b></font> <b>Kлонирование массива</b><br><br>• Используя метод <b>Array.slice()</b><br>• Использование оператора <b>spread</b>-<br>Оператор <u>spread</u> позволяет вам разложить массив на отдельные элементы, которые затем можно использовать для создания нового массива:<br><mark>const originalArr = [1, 2, 3];<br>const clonedArr = [...originalArr];</mark><br><br>• Используя метод <b>Array.from()</b>:<br><mark>const originalArr = [1, 2, 3];<br>const clonedArr = Array.from(originalArr)</mark><br><br>• Используя метод <b>Array.concat()</b> - <br>Этот метод создает новый массив путем объединения двух или более массивов вместе:<br><mark>const originalArr = [1, 2, 3];<br>const clonedArr = [].concat(originalArr);</mark><br><br> •Использование <b>цикла for</b><br><br> •Используя метод <b>Array.map()</b>:<br><mark>const originalArr = [1, 2, 3];<br>const clonedArr = originalArr.map(x => x);</mark><br><br><font color=\"red\"><b>*</b></font> <b>МЕТОДЫ МАССИВА:</b><br><br><b>• push()</b> – добавляет элементы в конец,<br><br><b>• pop()</b>  – извлекает элемент из конца,<br><br><b>• shift()</b> – извлекает элемент из начала,<br><br><b>• unshif)</b> – добавляет элементы в начало.<br><br><b>• splice()</b>  – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.<br><br><b>• slice()</b>  возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end)<br><br><b>• some()</b>  Этот метод проверяет, удовлетворяет ли какой-либо элемент массива условию,заданному в передаваемой функции. Он вернет значение true, если хотя бы один элемент совпадет с проверяемой функцией <mark>arr.some(el => el === \"d\")</mark><br><br><b>• every()</b> проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.<br>Он вернет значение true, если каждый элемент совпадет с проверяемой функцией, и значение false — если нет.<br><mark>arr.every(test => test === \"d\")</mark><br><br><b>• reduce()</b> принимает функцию, которая имеет в качестве аргумента аккумулятор и значение.Он применяет функцию к аккумулятору и каждому значению массива, чтобы в результате вернуть только одно значение.<br><mark> arr.reduce((total, value) => total * value)</mark><br><br><b>• map()</b>-вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.<br><br><b>• find()</b>  ищет один (первый) элемент, который заставит функцию вернуть true.<br><mark>arr.filter(item => item.id < 3)</mark><br><br><b>• filter()</b>  возвращает массив из всех подходящих элементов<br><br><b>• forEach()</b> применяет функцию к каждому элементу массива. Ничего не возвращает.<br><mark>arr.forEach(element => console.log(element.name))</mark><br><br><b>• findIndex()</b>  возвращает индекс найденного элемента, если элемент удовлетворяет условию. Если не удовлетворяет, возвращается –1<br><br><b>• includes(value) </b>  – возвращает true, если в массиве имеется элемент value, в противном случае false.<br><br><b>• split/join</b>  – преобразует строку в массив и обратно.<br><br><b>• concat()</b>  метод объединяет два или более массива/значения и возвращает новый массив//arr.concat(arr2)<br><br><b>• reverse()</b><br><b>Array.isArray(arr)</b> проверяет, является ли arr массивом."  
  },

  {  
    "parent": "Объекты",
    "title": "Объекты",
    "text": "<b>Объекты</b> – это один из типов данных в JavaScript, который предназначен для хранения коллекции различных значений и более сложных сущностей.<br><br><font color=\"red\"><b>*</b></font> Работа с любыми объектами ведется исключительно по ссылке.<br><br>Они хранят свойства (пары ключ-значение), где:<br>• Ключи свойств должны быть строками или символами (обычно строками).<br>• Значения могут быть любого типа.<br><br>Чтобы получить доступ к свойству, мы можем использовать:<br>• Запись через точку: <mark>obj.property</mark>.<br>• Квадратные скобки <mark>obj[\"property\"]</mark>. <br>Квадратные скобки позволяют взять ключ из переменной, например, <mark>obj[varWithKey] </mark>.<br><br>Дополнительные операторы:<br>• Удаление свойства: <mark>delete obj.prop</mark>.<br>• Проверка существования свойства: <mark>\"key\" in obj</mark><br>• Перебор свойств объекта: цикл <mark>for (let key in obj). </mark><br><br><font color=\"red\"><b>*</b></font> Одно из главных отличий объектов от примитивов заключается в том, что <b>объекты хранятся и копируются «по ссылке»</b>, тогда как примитивные значения – всегда копируются «как целое значение».<br><br>Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.<br><br><br><br><font color=\"red\"><b>*</b></font> <b>Сравнение по ссылке</b><br>  Два объекта равны только в том случае, если это один и тот же объект.<br><br><font color=\"red\"><b>*</b></font><b> Клонирование и объединение:</b><br><br>const food = { beef: '?', bacon: '?' }<br>// \"Spread\"<br><mark>{ ...food }</mark><br><br>// \"Object.assign\"<br> <mark>Object.assign({}, food)</mark><br><br>// \"JSON\"<br><mark>JSON.parse(JSON.stringify(food))</mark><br><br>// structuredClone<br><mark>const copied = structuredClone(calendarEvent</mark>)<br><br>• Использование <b>спред-оператора</b> или метода <b>Object.assign() (поверхностное клонирование) </b>. <br>Метод Object.assign копирует все свойства из одного или нескольких исходных объектов в один целевой объект.<br><br><b>• Преобразование объекта в строку JSON и обратно</b> Метод JSON.stringify позволяет передать объект в первом аргументе для преобразования в строковый формат. <br>После преобразования объекта в строку можно взять эту строку и преобразовать её обратно в исходный объект, используя метод JSON.parse.<br><br>• Использование глобального метода  <b>structuredClone</b>. <br>StructuredClone — Функция structuredClone создаёт новый объект с теми же свойствами, что и исходный объект, и все свойства, которые являются объектами, также клонируются."  
  },

  {  
    "parent": "Деструктуризация",
    "title": "Деструктуризация",
    "text": "<b>Деструктурирующее присваивание</b> – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.<br><br>Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее. <br><br><b>1. Деструктуризация массива</b><br><br><mark>let [firstName, surname] = \"Evgeniy Pryanichnikov\".split(\" \"); </mark><br><mark>console.log(firstName); // Evgeniy</mark><br><mark> console.log (surname);  // Pryanichnikov </mark><br><br><b>2. Остаточные параметры \"…\"</b><br>Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор <b>остаточные параметры:</b><br><br><mark>let [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"Troy\" ];</mark><br><br><font color=\"red\"><b>*</b></font> Переменная <b>rest</b> является массивом из оставшихся элементов.<br><br>Вместо rest можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании.<br><br><b>3. Деструктуризация объекта</b><br><br>let options = {<br> &nbsp;&nbsp;title: \"Menu\",<br>&nbsp;&nbsp;width: 100,<br>&nbsp;&nbsp;height: 200<br>};<br><mark>let {title, width, height} = options;</mark><br>Свойства options.title, options.width и options.height присваиваются соответствующим переменным."  
  },

  {  
    "parent": "Параметры по умолчанию",
    "title": "Параметры по умолчанию",
    "text": "<b>Параметры по умолчанию в JavaScript</b> позволяют задавать параметрам функции значения по умолчанию в случае, если функция вызвана без аргументов или если параметру явным образом передано значение undefined.<br><br>В JavaScript параметры функции, которым при её вызове не передаются значения, принимают по умолчанию значение undefined. Однако в некоторых случаях может быть полезно задать иное значение по умолчанию. Именно для таких случаев предназначены параметры по умолчанию.<br><br><font color=\"red\"><b>*</b></font> Параметры по умолчанию вычисляются в момент вызова функции.<br><br><u>Вот простой пример:</u><br><mark>let getFinalPrice = (price, tax = 0.7) => price + price * tax; </mark><br><mark>getFinalPrice(500); </mark> // 850, так как значение tax не задано<br><mark>getFinalPrice (500, 0.2); </mark> // 600, значение tax по-умолчанию заменяется на 0.2"  
  },

  {  
    "parent": "Стрелочные функции",
    "title": "Стрелочные функции",
    "text": "<b>Стрелочные функции</b> — это более компактный и удобный синтаксис для определения функций в JavaScript по сравнению с обычными функциями. <br><u>Синтаксис стрелочных функций:</u><br><br>• У них нет имени и ключевого слова function. Вместо них в круглых скобках сразу же пишутся параметры. За ними идёт стрелка  =>, а после неё — фигурные скобки с телом функции.  <br><br> • Стрелочную функцию можно записать ещё короче. Если её тело состоит из одного выражения (действия), фигурные скобки и ключевое слово return не нужны.  <br><br>Примеры стрелочных функций:<br><mark>• const sum = (a, b) => a + b;</mark><br> Задаёт функцию, которая принимает два аргумента с именами a и b.<br> И при выполнении она вычисляет выражение a + b и возвращает результат.  <br><br>• Если у функции только один параметр, круглые скобки можно отбросить <br>Например, <mark>const square = a => a * 2</mark><br><br><b>Стрелочные функции не имеют собственного контекста выполнения (this). </b><br><br><font color=\"red\"><b>*</b></font> Они берут значение this из окружающего контекста."  
  },

  {  
    "parent": "Классы",
    "title": "Классы",
    "text": "<b><mark>Что такое класс</b>?</mark><br>Это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные свойства и методы<br><br><b><mark>Что такое constructor()?</mark></b><br>Это специальный метод внутри класса, который используется для инициализации экземпляра класса, в нём устанавливаются начальные значения свойств.<br>Если не определить собственный конструктор, будет создан стандартный конструктор, представляющий собой пустую функцию, не влияющую на экземпляр.<br><br><b><mark>Свойства класса? </mark> </b><br>Свойства класса - это переменные, в которых хранится нужная информация. Свойства могут быть разделены на две группы:<ol><li>• Свойства экземпляров класса</li><li>• Статические свойства - это свойства принадлежащие всему классу в целом, а не отдельным экземплярам. Объявляются с помощью ключевого слова static. Наследуются.</p></li></ol></p><p>• Свойства также имеют два уровня доступа::<ol><li>• Открытые</li><li>• Приватные - не могут быть получены за пределами класса. Объявляют с префиксом #. Не наследуются.</li></ol></p><br><br><b><mark>Методы класса? </mark> </b><br>Это функции, с помощью которых можно получать и изменять свойства и вызывать другие методы</p><p>Методы могут быть разделены на две группы:<ol><li>Методы экземпляров класса</li><li>Статические методы - это методы, принадлежащие самому классу. Они определяют логику класса, а не его экземпляров. Объявляются с помощью ключевого слова static. Наследуются.</li></ol><p>Методы также имеют два уровня доступа::<ol><li>Открытые</li><li>Приватные - методы, которые не могут быть вызваны за пределами класса. Объявляют с префиксом #. Не наследуются</li></ol></p><br><br><b><mark>Что такое наследование классов? </mark> </b><br><p>Это способ расширения одного класса другим классом.<br>Наследование реализуется с помощью ключевого слова extends:<br>class Child extends Parent.<br>Объект класса Child будет иметь собственные методы, при этом у него будет доступ к методам Parent</p><br><br><b><mark>Что такое переопределение конструктора в классах? </mark> </b><br><p>Для переопределения в конструкторе класса необходимо вызвать сначала конструктор родителя: super(foo) и после этого будет создаваться this, который можно будет расширять или переопределять.</p><br><br><b><mark>Метод проверки относится ли объект к классу? </mark> </b><br><p>obj instanceof Class</p><br><br><b><mark>Добавление новых методов в класс? </mark> </b><br><p>Мы можем добавить новый метод в класс с помощью свойства prototype, при этом новый метод будет доступен у всех ранее созданных экземпляров класса.</p>"  
  },

  {  
    "parent": "DOM",
    "title": "DOM",
    "text": "Браузер, перед тем как показать вам запрашиваемую страницу, выполняет большое количество различных действий. Самое важное здесь понять, что <b>браузер не работает с HTML-страницей напрямую как с текстом, а строит для этого DOM</b>.<br><br><mark><b>DOM</b></mark> – это объектная модель документа (Document Object Model). Представляет она собой древовидную структуру страницы, состоящую из узлов. <br>Каждый узел в ней – это объект, который может иметь определённые свойства и методы. <br>Иными словами, можно сказать, что DOM – это набор иерархически связанных между собой объектов.<br><br><b>Зачем браузер строит DOM?</b>  <br>В основном это связано с тем, что прочитанный HTML-код ему нужно как-то представить в памяти и было решено, что оптимально это будет сделать в виде древовидной структуры. После того как браузер построил DOM, он его использует в дальнейших процессах, конечной целью которых является построение отображения этой страницы на экране.<br><br><b>Процесс перевода HTML-кода страницы в DOM выполняет парсер. </b>  <br>При этом он это делает даже если HTML-код содержит ошибки, но так как он в данном случае это «понимает».<br><br><mark>При этом <b>DOM</b> не является статической структурой. Её можно изменять с помощью JavaScript и тут же видеть эти изменения на экране.</mark><br> Для этого браузер нам предоставляет <b>API.</b> То есть благодаря DOM, мы можем с помощью JavaScript изменять содержимое страницы на лету. <br>Таким образом, JavaScript – это ключевая технология для создания динамических веб-сайтов и веб-приложений. Без неё, каким-то других способом это сделать невозможно.<br><br>Перед тем как перейти к изучению DOM, рассмотрим сначала все основные этапы работ, которые браузер выполняет для преобразования исходного кода HTML-документа в отображение стилизованной и интерактивной картинки на экране. <br>Этот процесс называется <b>Critical Rendering Path (CRP).</b>(см. следующий раздел)"  
  },

  {  
    "parent": "Critical Rendering Path (CRP)",
    "title": "Critical Rendering Path (CRP)",
    "text": "<mark><b>Критические этапы рендеринга</b></mark> (Critical Rendering Path) - это последовательность шагов, которые выполняет браузер, когда преобразуется HTML, CSS и JavaScript в пиксели, которые вы видите на экране. <br>Этот процесс называется Critical Rendering Path (CRP).<br><br><b><mark>Понимание этапов (CRP)</mark></b><br>Существует 6 этапов CRP:<br><br><b>• Построение DOM-дерева. </b> <br>Это объект, представляющий полностью разобранную HTML-страницу. Начиная с корневого элемента <html>, узлы создаются для каждого элемента/текста на странице.<br><br><b>• Построение CSSOM-дерева. </b><br>CSSOM (CSS Object Model) — это объектное представление стилей DOM.<br><br><b>• Запуск JavaScript. </b><br><br><b>• Создание Render-дерева. </b> <br> Движок браузера комбинирует DOM и CSSOM, чтобы создать дерево рендера, в котором вычисляет стили для каждого видимого элемента страницы.<br><br><b>• Генерация раскладки.</b><br> Определяет положение и размеры элементов этого дерева.<br><br><b>• Отрисовка.</b> <br>На этом шаге видимый контент страницы преобразуется в пиксели, чтобы появиться на экране.<br><br><font color=\"red\"><b>* </b></font>Загрузка веб-страницы или приложения начинается с запроса HTML. Сервер возвращает HTTP-ответ, состоящий из заголовков (headers) и тела запроса. Именно в теле запроса содержится HTML-документ. <br>Браузер начинает парсить загружаемый HTML, преобразуя полученные байты документа в DOM-дерево. Браузер создаёт новый запрос каждый раз, когда он находит ссылки на внешние ресурсы, будь то файлы стилей, скриптов или ссылки на изображения. Некоторые запросы являются блокирующими. Это означает, что пока такие запросы выполняются - другие запросы приостанавливаются. Браузер продолжает парсить HTML и создавать DOM до тех пор, пока запрос на получение HTML не подходит к концу.<br> После завершения парсинга <b>DOM</b>, браузер конструирует CSS модель.<b>(CSSOM)</b>.<br> Как только эти модели сформированы, браузер строит дерево рендера <b>(render tree)</b>, в котором вычисляет стили для каждого видимого элемента страницы. <br>После формирования дерева происходит компоновка <b>(layout)</b>, которая определяет положение и размеры элементов этого дерева. Как только этап завершён - страница рендерится. Или \"отрисовывается\" <b>(paint)</b> на экране. "  
  },

  {  
    "parent": "Методы работы с DOM элементами",
    "title": "Методы работы с DOM элементами",
    "text": "<mark><b>Создание, вставка и удаление элементов</b></mark><br><u>Создание узлов:</u><br><b>• document.createElement(tag)</b> – создаёт элемент с заданным тегом,<br><br><b>• document.createTextNode(value)</b> – создаёт текстовый узел (редко используется)<br><br><b>• elem.cloneNode(deep) </b>– клонирует элемент, если deep==true, то со всеми дочерними элементами<br><br><u>Вставка и удаление узлов или текста:</u><br><b>• node.append</b>(...nodes or strings) – вставляет в конец узла<br><b>• node.prepend</b> (...nodes or strings) – вставляет в начало узла<br><b>• node.before</b> (...nodes or strings) – вставляет перед узлом<br><b>• node.after</b> (...nodes or strings) – вставляет сразу после узла<br><b>• node.replaceWith</b> (...nodes or strings) – заменяет узел<br><b>• node.remove() </b>– удаляет node<br><br>Перечисленными методами можно вставлять несколько элементов через запятую. Так же данные методы вставляют строки с вёрсткой как текст, поэтому <u>если нужно вставить фрагмент HTML, то используем</u>:<br><b>• node.insertAdjacentHTML(where, html)</b> вставляет в зависимости от where:<br><b>\"beforebegin\"</b> – вставляет html прямо перед elem<br><b>\"afterbegin\"</b>  – вставляет html в elem в начало<br><b>\"beforeend\"</b>  – вставляет html в elem в конец<br><b>\"afterend\"</b>  – вставляет html сразу после elem<mark><br><br><b>Методы ПОЛУЧЕНИЯ элементов документа.</b></mark><br><b>• querySelector</b> - это document метод, который возвращает первый элемент, соответствующий указанному селектору или группе селекторов. Если поиск не увенчался успехом возвращается значение null<br><br><b> • querySelectorAll</b> - это document метод, который возвращает коллекцию (статический NodeList) всех найденных элементов на странице, соответствующие указанному селектору или группе селекторов. Если поиск не увенчался успехом возвращается пустой NodeList.<br><br><b> • getElementById</b><br><br> - возвращают живую коллекцию HTML-элементов (на английском live HTMLCollection). То есть коллекцию содержимое которой автоматически обновляется при изменении DOM.<br><br><b> • getElementsByName</b><br><br><b> • getElementsByTagName</b><br><br><b> • getElementsByClassName</b><br><br> <b> • elem.matches(css) </b>  - проверяет , совпадает ли элемент CSS-селектору<br><br><b> • elem.closest(css) </b>  - ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору.<br><br><b><mark>Перебор</mark></b><br>Перебор NodeList (статический) обычно осуществляется с помощью <b>forEach</b>.Также перебрать набор выбранных элементов можно с помощью цикла <b>for</b> или <b>for...of</b>.<br><br> Экземпляры класса HTMLCollection (динамический) не имеют в прототипе метод forEach. Поэтому если вы хотите использовать этот метод для перебора такой коллекции, её необходимо преобразовать в массив.<br><br><b><mark>Методы для работы с классами и стилями</mark></b><br><u>Классы:</u><br><br><b>• elem.className </b>- полностью заменяет весь класс<br><br><b>• elem.classList.add/remove(class) </b>- добавляет/удаляет класс<br><br><b>• elem.classList.toggle(class) </b> - добавить класс если его нет, иначе удалить<br><br><b>• elem.classList.contains(class) </b> - проверка наличия класса<br><br><u>Стили: </u><br><br><b>• elem.style</b> - изменение атрибута style элемента. Свойства из одного слова записывается с маленькой буквы, из двух и более с помощью camelCase<br><br><b>• elem.style.display = “”</b> - сброс стилей, присваиваем пустую строку указанному стилю. <br><br><b><mark>Получение и установка контента элементам</mark></b><br><b>• textContent </b>– это свойство, которое предназначено для работы с текстовым контентом элемента. Оно позволяет его как получить (включая текстовое содержимое всего его потомков), так и установить<br>const text = elem.textContent;<br><br><b>• innerHTML и outerHTML</b><br><u>innerHTML</u> предназначен для установки или получения HTML разметки элемента.<br>elem.innerHTML<br><br><u>outerHTML</u><br>Свойство outerHTML устанавливает или возвращает HTML контент, представляющий сам элемент и его дочерние элементы."  
  },

  {  
    "parent": "События",
    "title": "События",
    "text": "1. Событие<br>2. Обработчик события<br>3. Способы задания событию обработчика<br>4. Объект события<br>5. Свойства и методы объекта события<br><br><mark><b>Событие</b></mark> – это определённый сигнал от браузера. Он сообщает нам о том, что что-то произошло.<br><br><u>Например: </u><br>щелчок мыши, нажатие клавиши на клавиатуре, изменение размера области просмотра, завершение загрузки документа и т.д.<br>При этом сигнал всегда связан с объектом. Подавать сигналы могут различные объекты: window, document, DOM-элементы и т.д.<br>Список некоторых событий и их название:<br><b>• DOMContentLoaded</b> – завершение загрузки DOM<br><br><b>• click</b>  – клик (нажатие левой кнопки мыши, на устройствах с сенсорным управлением возникает при касании)<br><br><b>• keydown</b> – нажатие клавиши на клавиатуре<br><br><b>• resize</b> – изменение размеров документа<br><br><b>• change</b>  – окончание изменения значения в поле ввода.<br><br><b><mark>Обработчик события</mark></b><br>Зачем нам события? Они нам нужны для того, чтобы мы могли <b>реагировать на них</b>, или другими словами выполнять определённые действия, когда они произойдут.<br>В JavaScript это выполняется посредством привязывания некоторой функции к событию. <br>После этого эта функция будет вызываться всякий раз, когда это событие на указанном элементе будет возникать. Эту функцию в JavaScript принято называть <b>обработчиком события.</b><br><br><b><mark>Способы задания событию обработчика</b></mark><br>• <b>через HTML-атрибут on{событие}</b> (не является хорошей практикой)<br><br><b>• посредством свойства DOM-элемента on{событие}</b><br>const btn = document.querySelector('#my-btn');<br>btn.onclick = function() {<br>&nbsp;&nbsp;console.log(CLICK!');<br>}<br><br>• используя специальный метод <b>addEventListener</b>.<br><u>element.addEventListener(event, handler[, options])</u>;<br>Параметры:<br><u>•event</u> - имя события (например, click);<br><u>•handler</u> - функция, которая будет вызвана при возникновении этого события;<br><u>•options</u> (не обязательный) - объект, в котором можно задать дополнительные параметры.<br><br><font color=\"red\"><b>* </b></font> В options можно задать:<br><u>once</u>  - если true, то обработчик будет вызван всего один раз;<br><u>capture</u>  - задаёт фазу, на которой нужно вызвать обработчик события (по умолчанию - на этапе всплытия); если нужно на этапе погружения (перехвата) - то этому ключу следует установить значение true;<br><u>passive</u>  - определяет, следует ли вызывать preventDefault(); если установить true - то обработчик никогда не вызовет этот метод.<br><br>Кроме этого, options можно установить true или false, в этом случае он будет просто определять фазу (всплытие или погружение).<br><br><b><mark>Как получить информацию о событии? </mark></b><br>Получить детальную информацию о событии в обработчике можно посредством <b>объекта события (Event)</b>. <br>Данный объект создаёт браузер, когда это событие происходит. В него он помещает много различной информации. Например, для события click: какая клавиша нажата, координаты курсора и др.<br><br><font color=\"red\"><b>*</b></font> <b>Объект события</b> в соответствии со стандартом всегда передаётся обработчику посредством первого аргумента:<br><br>document.addEventListener('click', function(e) {<br>&nbsp;&nbsp;console.log(e)<br>}). <br><br><b><mark>Свойства и методы объекта события</mark></b><br><u>Свойства объекта Event</u>:<br><b>bubbles</b> – логическое значение, указывающее на то является ли данное событие всплывающим;<br><b>cancelable</b> – определяет можно ли событие отменить;cancelBubble – при установке true предотвращает всплытие события, т.е. оно всплывать не будет (является псевдонимом метода stopPropagation);<br><b>composed</b> – указывает может ли событие всплывать через из теневого DOM (внутреннего DOM конкретного элемента) в обычный DOM документа;<br><b>currentTarget</b> – элемент, привязанный к обработчику события;<br><b>defaultPrevented</b> – показывает был ли для события вызван метод preventDefault;<br><b>eventPhase</b> – число, указывающее фазу процесса распространения события (0 – не обрабатывается, 1 – погружение, 2 – целевой элемент, 3 – всплытие);<br><b>isTrusted</b> – указывает вызвано ли событие действием пользователя или программно (посредством использования метода dispatchEvent);<br><b>returnValue</b> – альтернатива для preventDefault;<br><b>target</b> – элемент, который создал событие;<br><b>timestamp</b> – время, когда произошло событие;<br><b>type</b> – тип (имя) события.<br><br><font color=\"red\"><b>* </b></font> События в браузере по умолчанию всплывают. <br>Из-за этого:<br><b>target</b> – элемент, который вызвал событие;<br><b>currentTarget</b> – элемент, к которому прикреплен обработчик события.<br><br><u>Методы объекта Event: </u> <br><b>preventDefault</b> – отменяет событие, если его конечно можно отменить;<br><b>stopPropagation</b> – предотвращает всплытие события."  
  },

  {  
    "parent": "Cookies",
    "title": "Cookies",
    "text": "<b><mark>Cookies</mark></b> - это технология, позволяющая сайтам сохранять в браузере небольшую порцию данных (до 4Кбайт).<br>Обычно эти данные используются на сайте для того, чтобы:<br><b>• Идентификация пользователя.</b> - Если пользователь дал согласие на куки, авторизовался на сайте и потом зашёл на него повторно, ему не придётся заново вводить логин и пароль. Сайт уже его помнит, и авторизация произойдёт автоматически.<br><br><b>• Настройка индивидуального профиля.</b> - С помощью куки сайты запоминают город, язык, масштаб страницы, товары в корзине и другие данные. При повторном посещении сайта пользователю не нужно ещё раз всё настраивать. <br><br><b>• Фиксация действий.</b> -  Это делает работу с сайтом удобнее. Например, позволит быстро найти товар, который заинтересовал при прошлом посещении. <br><br><b>• Польза для бизнеса.</b> -  С их помощью можно выявить предпочтения пользователей и адаптировать контент сайта или настроить таргетированную рекламу. Например, интернет-магазин собрал информацию о категориях товаров, которыми чаще всего интересовался посетитель сайта. На основе этих данных при повторном посещении ему можно показать релевантные товары или порекомендовать тематические статьи.<br><br><b><mark>Как работают cookies</mark></b><br>Механизм работы с cookies рассмотрим на следующем примере:<br>• Клиент (веб-браузер) посылает серверу запрос (запрашивает у него страницу). Если в браузере есть cookies, связанные с этим сайтом, то он их посылает серверу в составе этого запроса.<br><br>• Сервер получает запрос от клиента. Если в составе запроса есть куки, то их можно использовать для выполнения некоторой логики на сервере, подготовки пользователю персонализированной страницы или для чего-то другого. После этого отправляем клиенту ответ. В заголовке ответа отправляем веб-браузеру (клиенту) cookies, которые ему нужно будет сохранить.<br><br>• Веб-браузер (клиент) получает ответ от сервера (страницу) и выводит его пользователю. Куки, которые пришли с сервера, браузер сохраняет в своё хранилище.<br><br><b><mark>Прочитать и установить cookies</mark></b> можно не только на стороне сервера, но и на клиенте - с помощью JavaScript. <br>Осуществляется это посредством свойства <b>cookie</b> объекта <b>document</b>.<br>const cookies = document.cookie (получаем все куки страницы).<br><br><font color=\"red\"><b>* </b></font>Значение document.cookie состоит из пар ключ=значение, разделённых ;. Каждая пара представляет собой отдельное куки.<br><br>Так же можем пзаписывать куки в document.cookie.<br>Но это не просто свойство данных, а акcессор (геттер/сеттер). Присваивание к нему обрабатывается особым образом.<br><br><font color=\"red\"><b>* </b></font>Запись в document.cookie обновит только упомянутые в ней куки, но при этом не затронет все остальные.<br>Технически, и имя и значение куки могут состоять из любых символов, для правильного форматирования следует использовать встроенную функцию <b>encodeURIComponent</b>:<br><br>let name = \"my name\";<br>document.cookie = encodeURIComponent(name). <br><br>У куки есть <mark><b>ряд настроек</b></mark>git, многие из которых важны и должны быть установлены:<br><b>• path=/mypath</b> - куки будут доступны для страниц под этим путём. Если куки установлено с path=/admin, то оно будет доступно на страницах /admin и /admin/something<br><b>• domain=site.com</b> - Домен определяет, где доступен файл куки.<br><b>• expires, max-age</b> - если куки не имеют ни одного из этих параметров, то они удалятся при закрытии браузера. Такие куки называются сессионными. Данные параметры определяют дату истечения срока действия куки, когда браузер удалит его автоматически.<br><b>• secure</b> - куки будет доступно только через https"
  },

  {  
    "parent": "LocalStorage и SessionStorage",
    "title": "LocalStorage и SessionStorage",
    "text": "Объекты веб-хранилища <b><mark>localStorage</mark></b> и <b><mark>sessionStorage</b></mark> позволяют хранить пары ключ/значение в браузере.<br><br>Что в них важно – данные, которые в них записаны, сохраняются после обновления страницы (в случае sessionStorage) и даже после перезапуска браузера (при использовании localStorage). Скоро мы это увидим.<br><br>Но ведь у нас уже есть куки. Зачем тогда эти объекты?<br><br>•В отличие от куки, объекты веб-хранилища <u>не отправляются на сервер</u> при каждом запросе. Именно поэтому мы можем хранить гораздо больше данных. Большинство современных браузеров могут выделить как минимум 5 мегабайтов данных (или больше), и этот размер можно поменять в настройках.<br><br>• Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.<br><br>•Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.<br><br><font color=\"red\"><b>* </b></font>Объекты хранилища <b>localStorage</b> и <b>sessionStorage</b> предоставляют одинаковые методы и свойства:<br><br>• <b>setItem(key, value)</b> – сохранить пару ключ/значение.<br>• <b>getItem(key)</b> – получить данные по ключу key.<br><br>•<b>removeItem(key)</b> – удалить данные с ключом key.<br><br>• <b>clear()</b> – удалить всё.<br><br>• <b>key(index) </b> – получить ключ на заданной позиции.<br><br>• <b>length</b> – количество элементов в хранилище.<br><br>Как видим, интерфейс похож на Map (setItem/getItem/removeItem), но также позволяет получить доступ к элементу по индексу – key(index). <br><br><b><h3>Основные особенности <mark>localStorage</mark></h3></b><br>• Этот <u>объект один на все вкладки</u> и окна в рамках источника (один и тот же домен/протокол/порт).<br>• <u>Данные не имеют срока давности</u>, по которому истекают и удаляются. Сохраняются после перезапуска браузера и даже ОС.<br><br>Например, если запустить этот код…<br><br>localStorage.setItem('test', 1);<br><br>…И закрыть/открыть браузер или открыть ту же страницу в другом окне, то можно получить данные следующим образом:<br><br>alert( localStorage.getItem('test') ); // 1<br><br>Нам достаточно находиться на том же источнике (домен/протокол/порт), при этом URL-путь может быть разным.<mark>Объект localStorage</mark> доступен всем окнам из одного источника, поэтому, если мы устанавливаем данные в одном окне, изменения становятся видимыми в другом. <br><br><h3>Основные особенности <mark>sessionStorage</mark></h3><br><b>Объект sessionStorage</b> используется гораздо реже, чем localStorage.<br>Свойства и методы такие же, но есть существенные ограничения:<br>sessionStorage существует только в рамках текущей вкладки браузера.Другая вкладка с той же страницей будет иметь другое хранилище.Но оно разделяется между ифреймами на той же вкладке (при условии, что они из одного и того же источника).<br><br><u>Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.</u><br><br>Давайте посмотрим на это в действии.<br>1. Запустите этот код… <br><mark>sessionStorage.setItem('test', 1)</mark>;<br><br>…И обновите страницу. <br>2. Вы всё ещё можете получить данные:<br><mark>alert( sessionStorage.getItem('test') )</mark>; // после обновления: 1<br><br>…Но если вы откроете ту же страницу в другой вкладке и попробуете получить данные снова, то код выше вернёт null, что значит «ничего не найдено».<br><br><font color=\"red\"><b>*</b></font><b>Так получилось, потому что sessionStorage привязан не только к источнику, но и к вкладке браузера</b>. Поэтому sessionStorage используется нечасто. <br><br><h3>Событие <mark>storage</mark>:</h3><br>• Срабатывает при вызове setItem, removeItem, clear.<br>• Содержит все данные об произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea.<br>• Срабатывает на всех объектах window, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри вкладки для sessionStorage, глобально для localStorage)."
  },

  {  
    "parent": "Fetch API / Ajax (XHR)",
    "title": "Fetch API / Ajax (XHR)",
    "text": "<b>AJAX (Асинхронный JavaScript и XML) и Fetch API</b> являются мощными инструментами, используемыми в современной веб-разработке для создания асинхронных HTTP-запросов.<br><br><h3>Ajax: Возможности и ограничения</h3><br><mark><b>Ajax (Asynchronous JavaScript and XML)</b></mark> — это технология, которая позволяет осуществлять асинхронные запросы к серверу без перезагрузки страницы.<br>Пример кода с <u>использованием Ajax</u>:<br><font color=\"grey\">1. Создаем новый объект XMLHttpRequest</font><br>var xhr = new XMLHttpRequest();<br><br><font color=\"grey\">2. Устанавливаем параметры запроса</font><br>xhr.open('GET', 'https://api.example.com/data', true);<br><br><font color=\"grey\">3. Устанавливаем обработчик события изменения состояния запроса</font><br>xhr.onreadystatechange = function() {<br>&nbsp;&nbsp;<font color=\"grey\">// Проверяем состояние запроса</font><br>&nbsp;&nbsp;&nbsp;if (xhr.readyState == 4 && xhr.status == 200){&nbsp;&nbsp;&nbsp;<font color=\"grey\"> // Получаем ответ от сервера</font>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;var response = JSON.parse(xhr.responseText);<br> &nbsp;&nbsp;&nbsp;<font color=\"grey\">// Обработка ответа</font><br>&nbsp;&nbsp;&nbsp;console.log(response);<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;};<br><font color=\"grey\">4. Отправляем запрос</font><br>xhr.send();<br><br><b><mark>Ограничения Ajax</mark> </b><br><b>Сложность кода</b>: Использование XMLHttpRequest требует более сложного кода с настройками и обработчиками событий. В отличие от более современных подходов, таких как Fetch API, Ajax требует больше усилий для настройки и управления.<br><b>Обработка ошибок</b>: В примере не показано, как обрабатывать ошибки. При использовании Ajax разработчикам необходимо явно проверять статус ответа и обрабатывать возможные ошибки, например, сетевые проблемы или ошибки сервера.<br><b>Отсутствие поддержки современных функций</b>: Ajax не поддерживает некоторые современные функции, такие как потоки и загрузка файлов. Если вам необходимо работать с большими объемами данных или осуществлять передачу файлов, Ajax может ограничить ваши возможности.<br><br><h3>Fetch API: Новое поколение асинхронных запросов</h3><br><mark><b>Fetch API</b></mark> — это новое поколение технологии для асинхронной передачи данных в веб-приложениях. <br>Он предоставляет простой и современный интерфейс для выполнения HTTP-запросов и получения ответов.<br> Fetch API был введен в JavaScript вместе с появлением стандарта <u>ES6</u> и быстро стал предпочтительным выбором для многих разработчиков.<br><br><font color=\"red\"><b>*</b></font> Одно из главных преимуществ Fetch API заключается в его простоте использования. <br>Он предоставляет единый метод <b>fetch()</b> для выполнения запросов и возвращает <b>Promise</b>, что делает код более понятным и удобным для разработчиков. Кроме того, Fetch API имеет встроенную поддержку потоковой передачи данных и загрузки файлов, что делает его более мощным и гибким в использовании.<br><br><b>1.Отправляем GET-запрос с помощью Fetch</b><br><mark>fetch(`https://students.ru/fe-diplom/routes/cities')</mark><br><br><b>2.Обрабатываем ответ</b><br>&nbsp;&nbsp;<mark>.then(response => response.json())</mark><br><br><b>3.Обрабатываем ошибку</b><br>&nbsp;&nbsp;<mark>.catch(err => console.log(err))</mark>. <br><br><b><mark>Преимущества Fetch API в этом примере:</mark></b><br><b>1.Простота использования</b>: <br>Fetch API предоставляет более простой и понятный интерфейс для выполнения запросов. Вместо создания нового объекта XMLHttpRequest и установки обработчиков событий, мы можем использовать метод fetch(), который возвращает Promise.<br><b>2.Встроенная обработка ошибок: </b><br> В примере с использованием Fetch API, мы можем использовать метод .catch() для обработки ошибок. Если запрос завершается неудачно (например, сетевая ошибка или ошибка сервера), промис переходит в состояние «отклонено», и мы можем обработать ошибку в блоке .catch().<br><b>3.Поддержка современных функций:</b><br> Fetch API поддерживает современные возможности, такие как потоковая передача данных и загрузка файлов. Это позволяет работать с большими объемами данных и осуществлять передачу файлов без необходимости в дополнительных библиотеках или комплексном коде."
  },

  {  
    "parent": "Event Loop",
    "title": "что такое Event Loop?",
    "text": "При <b>СИНХРОННОМ</b> выполнении задачи <b>страница  блокируется</b> и ждёт выполнения этого кода, прежде чем перейти к следущей задаче.<br>Пользователь не может взаимодействовать с интерфейсом!<br><br><b>АСИНХРОННОСТЬ</b>-подразумевает возможность выполнения одной задачи, во время ожидания выполнения другой.<br><br>Концепт, который называется <b><mark>Event Loop</mark></b>.<br>Пример с setTimeout:<br><br>Когда интерпретатор/движок JS бежит по коду, он закидывает каждую задачу (console.log) в CallStack (Стек Вызовов) и если задача синхронная, то он ее сразу выполняет и удаляет из стека вызовов. <br><br><b>Но если задача асинхронная</b>(setTimeout), то он <br>1. Закидывает её в <b>CallStack </b> (стек вызовов), <br><br>2. Регистрирует функцию, находящуюся внутри таймаута<br><br>3. Передает из стека вызовов в <b>WEB API</b>, в которых setTimeout выполняется параллельно, не блокируя синхронный код.<br><br>4. Далее, когда выполнится таймаут, она передается из этих API в <b>очередь задач</b> (Callback queue)<br><br>5. Где работает цикл <b>Event Loop</b> и поочерёдно закидывает задачи в <b>CallStack</b> и выполняет.<br><br>Так называемая очередь задач(Callback queue) на самом деле разделена на две очереди, первая - это <b>макротаски</b>, вторая - <b>микротаски</b>, и в первую очередь выполняются сначало микротаски, а потом макротаски. <br>К макротаскам относятся:  setTimeout'ы, setInterbal'ы, обработчики событий, загрузка картинок, вывод инпутов и.т.д., <br>а к микротаскам относятся: промисы, MutationObserver , queueMicrotask и впервую очередь стек будет выполнять их. <br><br>т.е получим: сначала все микротаски, 1 макротаска, все микротаски, 1 макротаска и т.д.<br><br><h3>Что такое очередь задач (Callback queue)?</h3><br>Если асинхронная функция попадает в стек вызовов, то она регистрируется Web API (если это setTimeout, то таймер отсчитывается именно в WebAPI) и оттуда отправляется в очередь задач. <br><br><b>Очередь задач делится на:</b><br><b>1. Макротаски</b> - таймеры, события, браузерные нюансы<br><br><b>2. Микротаски</b> - промисы, queueMicrotask (функция с помощью которой можно создать микротаск), mutationObserver (механизм, который позволяет следить за изменениями в DOM)<br><br><h3>Что такое Стек вызовов (Call stack)? )</h3><br>Это стек, который используется для хранения контекстов выполнения, создаваемых в ходе работы кода. Когда движок начинает обрабатывать скрипт, он создаёт глобальный контекст выполнения и помещает его в текущий стек. При обнаружении команды вызова функции, движок создаёт новый контекст выполнения для этой функции и помещает его в верхнюю часть стека. Движок выполняет функцию, контекст выполнения которой находится в верхней части стека. Когда работа функции завершается, её контекст извлекается из стека и управление передаётся тому контексту, который находится в предыдущем элементе стека. <br><br><h3>Что такое WebApi?</h3><br>Это интерфейс, предоставляемый браузером. С помощью него мы можем взаимодействовать с DOM-деревом, устанавливать таймеры, отслеживать клики по элементам, отправлять запросы и тд"
  },

  
  {  
    "parent": "Prototype",
    "title": "Prototype",
    "text": "<p><p>В JS почти каждый объект содержит <mark>специальное внутреннее свойство <b>[[Prototype]]</b></mark>, указывающее на его прототип, который является для него шаблоном и от которого он наследует методы и свойства.</p><br><p>При объявлении функции-конструктора или класса у них автоматически появляется свойство <mark><b>prototype</b></mark> - это объект и по умолчанию в нём находится единственное свойство constructor, которое содержит ссылку на саму эту функцию.<br><br>Этот объект будет автоматически назначаться всем объектам, которые будут создаваться с помощью этой фунцкции, в качестве прототипа</p><br><p>Объект-прототип в свою очередь тоже может иметь свой прототип и тд - это называется <b><mark>цепочкой прототипов</mark></b>. Заканчивается цепочка на глобальном классе Object, потому что он не имеет прототипа.</p><br><p>Когда мы пытаемся обратиться к свойству или методу объекта, поиск всегда начинается с самого объекта. Если данного свойства или метода у него нет, то поиск перемещается в прототип, потом в прототип прототипа и так далее.</p><br><p>Получить прототип объекта в JavaScript можно с помощью статического метода <mark>Object.getPrototypeOf</mark> или специального свойства __proto__.</p>"
  },

  {  
    "parent": "Scope",
    "title": "Scope. Области видимости",
    "text": "<b><mark>Область видимости</mark></b>  в JavaScript — <b>Концепция, которая определяет границы действия переменных.</b><br><br><mark>Область видимости решает проблему хаоса в коде.</mark><br> Без неё, все переменные были бы доступны везде, что приводило бы к ошибкам и конфликтам.<br> <br> Она может быть:<br> <b><mark>Глобальная</mark></b> Элементы программы открыты для использования в любой её части. Они объявляются за рамками функций и блоков.<br> <br> <b><mark>Локальная</mark></b> Элементы доступны только в определённом блоке или функции. Это помогает избежать конфликтов между элементами, объявленными в разных частях программы.<br> Локальную область видимости можно разбить на два типа:<br> <b>-Функциональная</b> Зона видимости элементов, объявленных внутри функции.<br><b>-Блочная</b> Зона видимости переменных, объявленных внутри блока кода."  
  },

  {  
    "parent": "Асинхронность",
    "title": "Асинхронность в JS?",
    "text": "<b><mark>Асинхронность</mark></b> в JavaScript — это стиль программирования, при котором результат работы функций доступен не сразу, а через некоторое время. <br><br><mark>JavaScript является однопоточным языком.</mark><br> В каждый момент времени может выполняться только одна команда, обрабатываемая в единственном — главном потоке, все остальные действия блокируются до окончания выполнения текущей команды. <br> В базовом JavaScript отсутствуют механизмы, которые сами были бы асинхронными, но при этом <b>веб-браузер предоставляет асинхронные возможности</b>, такие как таймеры, слушатели событий, сетевые запросы, а сам JavaScript даёт нам <b>инструменты для работы с асинхронностью:</b><br>1. <b>Колбеки</b><br>2. <b>Промисы</b><br>3. <b>Async/await</b><br><br><mark>Что такое Колбек?</mark><br><br><b> Коллбэк</b>  — это функция, которая должна быть выполнена после того, как другая функция завершит работу.<br><br>function doHomework(subject, callback) {<br>&nbsp;  &nbsp;alert(`Starting my ${subject} homework.`);&nbsp;  <br>&nbsp;&nbsp;&nbsp;callback();<br>}<br><br> Коллбэками называют функции, передаваемые другим функциям в качестве аргументов."  
  },

  {  
    "parent": "Promise",
    "title": "Что такое Промис?",
    "text": "Это объект, который используется для написания и обработки асинхронного кода.<br><br><b><mark>Объект Promise</mark></b> представляет собой результат успешного или неудачного завершения асинхронной операции.<br><b>Асинхронные функции возвращают объект Promise в качестве значения.</b><br>Внутри промиса хранится результат вычисления, которое может быть уже выполнено или выполнится в будущем.<br>Синтаксис: new Promise(function(resolve, reject) { ... });<br><br>При создании объекта Promise в конструктор единственным аргументом передаётся функция с двумя параметрами: resolve и reject, в теле функции указываем код, которые должен выполниться асинхронно. <br>После выполнения кода, вызывается  функция <b>resolve</b> чтобы перевести промис в состояние <mark>fulfilled</mark> , или <b>reject</b> чтобы перевести промис в состояние <mark>rejected</mark>.<br><br>Promise может находиться в <b>трёх состояниях</b>:<br><b><mark>ожидание (pending) </b></mark>: начальное состояние, не исполнен и не отклонён.<br><b><mark>исполнено (fulfilled) </b></mark>: операция завершена успешно.<br><b><mark>отклонено (rejected) </b></mark>: операция завершена с ошибкой.<br><br>При создании промис находится в ожидании (pending), а затем может стать исполненным (fulfilled), вернув полученный результат (значение), или отклонённым (rejected), вернув причину отказа. <br>В любом из этих случаев вызывается обработчик, прикреплённый к промису методом <b>then</b>. (Если в момент назначения обработчика промис уже исполнен или отклонён, обработчик всё равно будет вызван, т.е. асинхронное исполнение промиса и назначение обработчика не будет происходить в «состоянии гонки», как, например, в случае с событиями в DOM.)"  
  },

  {  
    "parent": "Hosting",
    "title": "Что такое Hosting?",
    "text": "<b><mark>Поднятие или hoisting</mark></b> — это механизм в JavaScript, в котором <b>переменные</b> и <b>объявления функций</b>, передвигаются вверх своей области видимости перед тем, как код будет выполнен.<br><br>Ещё до выполнения кода интерпретатор JavaScript загружает в память функции, объявленные как <b>function declaration</b>, а также объявления переменных и функций <b>function expression</b>, но не их значения. <br>В результате функцию <b>function declaration</b> можно вызвать ещё до того, как до неё дойдёт построчное выполнение кода.<br> <br> На этапе создания, движок JavaScript просматривает код и, как только он видит ключевое слово <b>var</b>или ключевое слово <b>function</b>, он выделяет некоторую память для них.   "  
  },

  {  
    "parent": "Замыкания",
    "title": "Что такое Замыкания?",
    "text": "<b>Замыкания — это одна из фундаментальных концепций JavaScript</b><br><br><b><mark>Замыкание</mark></b> — это функция, у которой есть доступ к области видимости, сформированной внешней по отношению к ней функции даже после того, как эта внешняя функция завершила работу.<br> Это значит, что в замыкании могут храниться переменные, объявленные во внешней функции и переданные ей аргументы. <br><br><b><mark>Что такое лексическое окружение?</mark></b><br>Понятие «лексическое окружение в JavaScript относится к возможности доступа к переменным, функциям и объектам на основе их физического расположения в исходном коде. "  
  },

  {  
    "parent": "Virtual DOM",
    "title": "Что такое Virtual DOM?",
    "text": "<b><mark>Virtual DOM</b></mark><br><br>Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. <br>Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM.<br>При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.<br><br>Такой подход работает быстрее, потому как не включает в себя все тяжеловесные части реального DOM.<br><br><b>React</b> создает легковесное дерево из JavaScript-объектов для имитации DOM-дерева. <br>Затем он создает из них HTML, который вставляется или добавляется к нужному DOM-элементу, что вызывает перерисовку страницы в браузере."  
  },

  {  
    "parent": "Веб-компоненты",
    "title": "Что такое Веб-компоненты",
    "text": "<b><mark>Веб-компоненты</mark></b> - это набор различных технологий, позволяющих создавать повторно используемые настраиваемые элементы с их функциональностью, инкапсулированной отдельно от остальной части вашего кода - и использовать их в ваших веб-приложениях. <br><br><b>Компонентная архитектура</b><br>Хорошо известное правило разработки сложного программного обеспечения гласит: <mark>не создавай сложное программное обеспечение.</mark><br Если что-то становится сложным – раздели это на более простые части и соедини наиболее очевидным способом.<br <br <b>Хороший архитектор – это тот, кто может сделать сложное простым.</b><br <br Мы можем разделить пользовательский интерфейс на визуальные компоненты: каждый из них занимает своё место на странице, выполняет определённую задачу, и отделен от остальных.<br><br>Компоненты могут содержать подкомпоненты, например сообщения могут быть частями родительского компонента «список сообщений». Кликабельное фото пользователя может быть самостоятельным компонентом и т.д.<br><br>Как мы определяем, что является компонентом? Это приходит из соображений здравого смысла, а также с интуицией и опытом. <br>Обычно это объект, отделимый визуально, который мы можем описать с точки зрения того, что он делает и как он взаимодействует со страницей. <br><br><b><mark>Компонент имеет:</mark></b><br>1. свой собственный JavaScript-класс.<br>2. DOM-структура управляется исключительно своим классом, и внешний код не имеет к ней доступа (принцип «инкапсуляции»).<br>3. CSS-стили, применённые к компоненту.<br>4. API: события, методы класса и т.п., для взаимодействия с другими компонентами.<br><br><b>Веб-компоненты состоят из трёх основных технологий</b>, которые можно использовать вместе для создания универсальных настраиваемых элементов с инкапсулированной функциональностью, которые можно повторно использовать где угодно, не опасаясь коллизий кода:<br><b><mark>Пользовательские элементы:</mark></b> набор API-интерфейсов JavaScript, позволяющих определять пользовательские элементы и их поведение, которые затем можно использовать по желанию в пользовательском интерфейсе.<br><br><b><mark>Shadow DOM: </mark></b>  набор API-интерфейсов JavaScript для прикрепления инкапсулированного «теневого» дерева DOM к элементу, который отображается отдельно от DOM основного документа, и управления соответствующими функциями. <br>Таким образом, вы можете сохранить функции элемента в секрете, поэтому для них можно создавать сценарии и стили, не опасаясь коллизий с другими частями документа.<br><br><b><mark>HTML templates: </mark></b> элементы <b>template</b> и <b>slot</b> позволяют создавать шаблоны разметки, которых не видно на отображаемой странице.<br> Затем их можно многократно использовать в качестве основы структуры настраиваемого элемента.<br><br><h3><b><mark>Пользовательские элементы (Custom Elements)</mark></b></h3><br>Мы можем создавать <mark>пользовательские HTML-элементы</mark>, описываемые нашим классом, со своими методами и свойствами, событиями и так далее.<br>Как только пользовательский элемент определён, мы можем использовать его наравне со встроенными HTML-элементами.<br>Это замечательно, ведь словарь HTML-тегов богат, но не бесконечен. Не существует <easy-tabs>, <sliding-carousel>, <beautiful-upload>… Просто подумайте о любом другом теге, который мог бы нам понадобиться.<br>Мы можем определить их с помощью специального класса, а затем использовать, как если бы они всегда были частью HTML.<br><br>Существует <b>два вида пользовательских элементов:</b><br><b>1. Автономные пользовательские элементы</b> – «полностью новые» элементы, расширяющие абстрактный класс HTMLElement.<br><b>2. Пользовательские встроенные элементы</b>– элементы, расширяющие встроенные, например кнопку HTMLButtonElement и т.п.<br><br><h3><b><mark>Shadow DOM</mark></b></h3><br><b>Теневой DOM («Shadow DOM»)</b> используется для инкапсуляции. Благодаря ему в компоненте есть собственное «теневое» DOM-дерево, к которому нельзя просто так обратиться из главного документа, у него могут быть изолированные CSS-правила и т.д.<br><br><b>Преимущества Shadow DOM:</b><br><b>1. Инкапсуляция кода и стилей</b>. Компоненты защищены от внешнего мира, что обеспечивает их надёжность и стабильность. <br><b>2. Повторное использование компонентов</b>.  Благодаря изоляции, компоненты легко переиспользуются в разных частях проекта или даже в разных проектах. <br><b>3. Упрощение масштабирования проектов</b>.  Когда каждый компонент является самодостаточным, управление большими проектами становится проще. <br><br><b>Теневое дерево</b><br>Каждый DOM-элемент может иметь <b>2 типа поддеревьев DOM:</b><br><br><b><mark>Light tree</b>– обычное, светлое, DOM-поддерево, состоящее из HTML-потомков. Все поддеревья, о которых мы говорили в предыдущих главах, были light.<br><b><mark>Shadow tree</b> – скрытое, теневое, DOM-поддерево, не отражённое в HTML, скрытое от посторонних глаз.<br>Если у элемента имеются оба поддерева, браузер отрисовывает только теневое дерево. Также мы всё же можем задать «композицию» теневого и обычного деревьев.<br><br><b>Инкапсуляция</b><br><b>Теневой DOM отделён от главного документа:</b><br>1. Элементы теневого DOM не видны из обычного DOM через querySelector. В частности, элементы теневого DOM могут иметь такие же идентификаторы, как у элементов в обычном DOM (light DOM). Они должны быть уникальными только внутри теневого дерева.<br>У теневого DOM свои стили. Стили из внешнего DOM не применятся.<br><br><h3><b><mark>Элемент \"template\"</mark></b></h3><br>Встроенный элемент <b>template</b> предназначен для хранения шаблона HTML. Браузер полностью игнорирует его содержимое, проверяя лишь синтаксис, но мы можем использовать этот элемент в JavaScript, чтобы создать другие элементы.<br>В теории, для хранения разметки мы могли бы создать невидимый элемент в любом месте HTML. Что такого особенного в <template>?<br>Во-первых, его содержимым может быть любой корректный HTML-код, даже такой, который обычно нуждается в специальном родителе.<br>Обычно, если элемент <tr> мы поместим, скажем, в <div>, браузер обнаружит неправильную структуру DOM и «исправит» её, добавив снаружи <table>. Это может оказаться не тем, что мы хотели. <template> же оставит разметку ровно такой, какой мы её туда поместили.<br>Также внутри <template> можно поместить стили и скрипты.<br>Браузер рассматривает содержимое <template> как находящееся «вне документа»: стили, определённые в нём, не применяются, скрипты не выполнятся, <video autoplay> не запустится и т.д.<br>Содержимое оживёт (скрипт выполнится), когда мы поместим его в нужное нам место."  
  },

  {  
    "parent": "Event Bubbling",
    "title": "Что такое Event Bubbling (Всплытие событий)?",
    "text": "<b><mark><h3><b><mark>Всплытие</b></mark></h3></b></mark><br>Принцип всплытия очень простой:<br>Когда на элементе происходит событие, <b>обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.</b><br><br><b>event.target</b><br><br>Всегда можно узнать, на каком конкретно элементе произошло событие.<br>Самый глубокий элемент, который вызывает событие, называется <b>целевым элементом</b>, и он доступен через <b>event.target</b>.<br><br><b>Прекращение всплытия</b><br><br>Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.<br>Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.<br>Для этого нужно вызвать метод <b>event.stopPropagation()</b>.<br><br><b><mark><h3><b><mark>Погружение</b></mark></h3></b></mark><br>В современном стандарте, кроме «всплытия» событий, предусмотрено ещё и <b>погружение</b>.<br><br Оно гораздо менее востребовано, но иногда, очень редко, знание о нём может быть полезным.<br>Строго говоря, стандарт выделяет целых три стадии прохода события:<br>1. Событие сначала идёт сверху вниз. Эта стадия называется <b>стадия перехвата</b> (capturing stage).<br><br>2. Событие достигло целевого элемента. Это – <b>стадия цели</b>(target stage).<br><br>3. После этого событие начинает всплывать. Это – <b>стадия всплытия</b> (bubbling stage).<br><br><b>Чтобы поймать событие на стадии перехвата</b>, нужно использовать <b>третий аргумент addEventListener</b>:<br>-Если аргумент <b>true</b>, то событие будет перехвачено по дороге вниз.<br>-Если аргумент <b>false</b>, то событие будет поймано при всплытии."  
  },

  {  
    "parent": "VUE",
    "title": "Вопросы по VUE",
    "text": "<mark><b>Что такое инстанс Vue? Как мы можем создать его?</mark></b><br><br>Это экземпляр VueJS, который является корнем всех приложений Vue. Это объект JavaScript, сформированный функцией-конструктором Vue и служащий отправной точкой для создания приложения Vue.<br><br><mark><b>Что такое компоненты?</mark></b><br><br> Компоненты являются строительными блоками с помощью которых можно разделять пользовательский интерфейс на более мелкие, независимые и переиспользуемые части.<br><br><mark><b>Какие виды компонентов есть во Vue?</mark></b><br><br> Однофайловый компонент или как объект JavaScript.<br><br><mark><b> Что такое двустороннее связывание?</mark></b><br><br> Это двустороннее связывание HTML-шаблона с моделью. Директива v-model обновляет модель при каждом изменении шаблона и обновляет шаблон при изменении модели.<br><br><mark><b> Что такое Props?</mark></b><br><br> Это входные параметры, которые может принимать компонент. Props используются для передачи данных от родительского компонента к его дочерним компонентам.<br><br><mark><b> Что такое v-bind?</mark></b><br><br> Динамически привязывает атрибуты или Props компонента к выражениям.<br><br><mark><b> Как работает реактивность?</mark></b><br><br> Реактивность - это концепция, которая позволяет адаптироваться к изменениям в декларативной форме. Во Vue - это изменение зависимых элементов при изменении объекта.<br><br><mark><b> Особенности использования v-model в Vue 2 и Vue 3</mark></b><br><br> <ol><li>Во Vue 2 можно использовать только одну директиву v-model. Во Vue 3 можно использовать сколько угодно директив v-model с явным указанием модели (v-model:title)</li><li>Vue 2 по умолчанию работает с атрибутом value. Vue 3 по умолчанию работает с атрибутом modelValue.</li><li>Во Vue 2 для изменения данных компонент, к которому применяем v-model должен эмитить событие input. Во Vue 3 событие update с указанием модели </li></ol><br><br><mark><b> Для чегo нyжeн $emit?</mark></b><br><br> $emit генерерирует в дочернем компоненте событие, а компонент-родитель может на это событие подписаться и выполнить некоторый обработчик.<br><br><mark><b> Как реализуется постраничная навигация в Vue в SPA?</mark></b><br><br> С помощью библиотеки VueRouter.<br><br><mark><b> Что такое computed свойства и как они работают?</mark></b><br><br> Computed свойство кэшируют результаты вычислений с участием указанных внутри него зависимостей, свойство будет пересчитываться только при изменении одной из его зависимостей.<br><br><mark><b> Как отследить изменение моделей?</mark></b><br><br> С помощью свойства watch.<br><br><mark><b> Особенности слежения за глубокими объектами?</mark></b><br><br> Создаём объект watch c названием объекта, в котором нужно отслеживать вложенные свойства. Первым свойством объекта идёт функция-обработчик, аргументом будет изменившееся поле. Вторым свойством объектом указываем deep: true.<br><br><mark><b> Что такое интерполяция?</mark></b><br><br> Форма привязки, с помощью фигурных скобок позволяет выводить в шаблон какие-либо данные.<br><br><mark><b> Как отрисовать компонент по условию?</mark></b><br><br> Директивы v-if, v-else и v-else-if или v-show.<br><br><mark><b> Paзницa мeждy v-if и v-show?</mark></b><br><br> v-show - применяет элементу display:none, v-if удаляет уэлемент из DOM-дерева.<br><br><mark><b> Что такое миксины ?</mark></b><br><br> Инструмент повторного использования кода в компонентах Vue. Объект микисна может содержать любые опции компонентов. При использовании миксина в компоненте все его опции «подмешиваются» к опциям компонента.<br><br><mark><b> Что такое директивы?</mark></b><br><br> Это специальные атрибуты, которые мы можем использовать внутри HTML-шаблона для настройки его поведения.<br><br><mark><b> Расскажите о жизненном цикле компонента Vue?</mark></b><br><br> <b>Жизненный цикл делится на несколько этапов</b>:<br><ul><li>Инициализация событий и сам жизненный цикл. Вызываются хук <b>beforeCreate</b></li><li>Инициализация реактивности и некоторых инъекций. Вызываются хук <b>created</b></li><li>Монтирование компонента. Вызываются хуки <b>beforeMount</b> и <b>mounted</b></li><li>Обновление компонента. Вызываются хуки <b>beforeUpdate</b> и <b>updated</b></li><li>Демонтирование компонента. Вызываются хуки <b>beforeUnmount</b> и <b>unmounted</b></li></ul><br><br><mark><b> В каком методе жизненного цикла необходимо делать первичную загрузку данных с сервера?</mark></b><br><br> mounted.<br><br><mark><b> В каком методе жизненного цикла необходимо делать очистку?</mark></b><br><br> unmounted.<br><br><mark><b> Как сделать стили локальными для компонента?</mark></b><br><br> Добавить флаг scoped.<br><br><mark><b> Как отрисовать несколько компонентов на основе массива?</mark></b><br><br> Директива v-for.<br><br><mark><b> Зачем указывать key при использовании директивы v-fог?</mark></b><br><br> Для правильной отрисовки изменений в списке элементов.<br><br><mark><b> Как отследить изменение конкретного поля объекта?</mark></b><br><br> Указываем в watch новую функцию следующего вида obj.prop.prop.(newValue).<br><br><mark><b> Зачем указывать key при использовании директивы v-fог?</mark></b><br><br> Для правильной отрисовки изменений в списке элементов.<br><br><mark><b> Можно ли изменять computed свойства ?</mark></b><br><br> Напрямую не рекомендуется, нужно изменить одну из зависимостей.<br><br><mark><b> Для чего нужен <b>vuex</b> и какие проблемы он решает?</mark></b><br><br> Vuex служит централизованным хранилищем данных для всех компонентов, при этом мы избавляемся от необходимости передавать данные сверху вниз, любой компонент может получать данные напрямую из хранилища.<br><br><mark><b> Расскажите о мутациях и экшенах в vuex. В чем отличие?</mark></b><br><br> Расскажите о мутациях и экшенах в vuex. В чем отличие?<br><br><mark><b> Каким способом можно получить DОМ элемент во Vuе ?</mark></b><br><br> ref.<br><br><mark><b> Как добавить класс на элемент по условию?</mark></b><br><br> :class.<br><br><mark><b> Расскажите о слотах в Vuе?</mark></b><br><br> Слоты во Vue позволяют передавать данные из родительского в HTML-шаблон дочернего компонента. Можно использовать несколько, для этого указать им имена через атрибуты name. В дочернем компоненте слоты обозначаются тегом slot, из родительского содержимое передаётся с помощью тега template.<br><br><mark><b> Как принудительно обновить компонент в Vue?</mark></b><br><br> $forceUpdate"  
  },

  {  
    "parent": "REACT",
    "title": "Вопросы по REACT",
    "text": "<b><mark>1. Какие хуки вы знаете?</b></mark><br><br><b>Хуки</b> – это функции-крючки, с помощью которых можно «прицепиться» к состоянию и методам жизненного цикла React из функциональных компонентов. <b>Хуки</b> – мощные инструменты для управления состоянием, обработки побочных эффектов и повторного использования логики:<br><br><b> useState</b><br>Используется для управления состоянием в функциональных компонентах<br><br><b>useEffect</b><br>Используется для выполнения побочных эффектов в функциональных компонентах (например, для получения данных или подписки на события)<br><br><b>useContext</b><br>Используется для доступа к значению контекста React в функциональном компоненте<br><br><b>useRef</b><br>Используется для создания изменяемых ссылок на элементы или значения, которые сохраняются во время рендеринга<br><br><b>useCallback</b><br>Используется для мемоизации функций для предотвращения ненужных повторных рендеров<br><br><b>useMemo</b><br>Используется для запоминания значений с целью повышения производительности за счет кэширования ресурсоемких вычислений<br><br><b>useReducer</b><br>Используется для управления состоянием с помощью функции reducer, аналогично тому, как это делается в Redux<br><br><b>useLayoutEffect</b><br>Используется для выполнения побочных эффектов подобно useEffect, с той разницей, что эффект запускается синхронно после всех мутаций DOM. <br><br><b><mark>2. Что такое виртуальный DOM?</b></mark><br><br><b>Виртуальный DOM в React</b> – концепция создания и хранения в памяти облегченного виртуального представления реальной DOM (объектной модели документа). Этот подход помогает оптимизировать производительность веб-приложений::<br><br><b>1. </b>Если данные или состояние React-компонента изменяются, вместо прямых манипуляций с реальной DOM-моделью обновляется виртуальная.<br><br><b>2. </b>Затем в виртуальной модели DOM вычисляется разница между предыдущим и обновленным состоянием компонента (с помощью diffing-алгоритма).<br><br><b>3. </b>После выявления различий React эффективно обновляет только необходимые части реальной DOM для отражения изменений.<br><br>Использование виртуальной DOM позволяет React создавать динамичные и интерактивные пользовательские интерфейсы, обеспечивая при этом оптимальную эффективность и скорость рендеринга. <br><br><b><mark>3. Как выполнить рендеринг элементов массива? </b></mark><br><br>Для рендеринга <b>статического</b> списка можно использовать метод <b>map()</b>, который перебирает элементы и возвращает новый массив элементов React:<br>{languages.map((language) => <li>{language}</li>)}<br><br>Для рендеринга элементов <b>динамического</b> списка используют <b>ключи</b>. Они необходимы для оптимизации процесса рендеринга, позволяя React быстро определить, какие элементы были изменены, удалены или добавлены.<br><br><b><mark>4. Чем управляемые компоненты отличаются от неуправляемых?</b></mark><br><br>Разница между управляемыми и неуправляемыми компонентами заключается в том, как они управляют своим состоянием и обновляют его.<br><br><b>Управляемые компоненты</b> – это компоненты, состояние которых контролируется React. Компонент получает свое текущее значение и обновляет его через реквизиты (пропсы). При изменении значения он также запускает функцию обратного вызова. <br>Это означает, что компонент не хранит собственное внутреннее состояние – вместо этого родительский компонент управляет им и передает значение управляемому компоненту.<br><br><b>Неуправляемые компоненты</b> , напротив, управляют своим состоянием самостоятельно с помощью ссылок или других методов. <br>Они хранят и обновляют свое состояние самостоятельно, не полагаясь на реквизиты или обратные вызовы. Родительский компонент имеет меньший контроль над состоянием неуправляемых компонентов.<br><br><b><mark>5. В чем разница между классовыми и функциональными компонентами?</b></mark><br><br>Основное различие между классовыми и функциональными компонентами заключается в способе их определения и используемом синтаксисе.<br><br><b>Классовые компоненты</b> – определяются как классы <b>ES6</b> и расширяют класс <b>React.Component</b>. <br>Они используют метод <b>render</b> для возврата JSX (JavaScript XML), определяющего вывод компонента. <br>Классовые компоненты имеют доступ к методам жизненного цикла компонента и управлению состоянием через this.state и this.setState().<br><br><b>Функциональные компоненты </b> определяются как простые функции JavaScript. <br>Они принимают в качестве аргументов реквизиты (props) и возвращают непосредственно JSX. <br><b>Функциональные компоненты не имеют доступа к методам жизненного цикла или состоянию</b>. Однако с появлением хуков в React 16.8 функциональные компоненты получили возможность управлять состоянием, использовать контекст и побочные эффекты. <br><br><b><mark>6. Что такое методы жизненного цикла компонента?</b></mark><br><br><b>Методы жизненного цикла</b> – это способ подключения к различным этапам жизненного цикла компонента, позволяющий выполнять определенный код в определенное время. <br>Вот список основных методов:<br><br><b>constructor </b>– первый метод, вызываемый при создании компонента. Он используется для инициализации состояния и привязки обработчиков событий. В функциональных компонентах для аналогичных целей используется хук useState.<br><br><b>render</b> – отвечает за рендеринг JSX-разметки и возвращает содержимое, которое будет выведено на экран.<br><br><b>componentDidMount</b> – вызывается сразу после рендеринга компонента в DOM. Обычно используется для задач инициализации, таких как вызов API или настройка слушателей событий.<br><br><b>componentDidUpdate</b> – вызывается при изменении реквизитов или состояния компонента. Позволяет выполнять побочные эффекты, обновлять компонент на основе изменений или запускать дополнительные вызовы API.<br><br><b>componentWillUnmount</b> – вызывается непосредственно перед удалением компонента из DOM. Используется для очистки ресурсов, которые были установлены в componentDidMount, например, для удаления слушателей событий или отмены таймеров. <br><br><b><mark>7. В чем заключаются особенности использования useState?</b></mark><br><br><b>useState</b> возвращает значение состояния и функцию для его обновления.<br><br>const [value, setValue] = useState('Some state');<br><br>Во время первого рендеринга возвращаемое состояние соответствует значению, переданному в качестве первого аргумента. <br>Для обновления состояния используется функция <b>setState.</b> Она принимает в качестве параметра новое значение состояния и ставит компонент в очередь на повторный рендеринг. <br>Функция <b>setState </b>может также принимать в качестве параметра функцию обратного вызова, которая принимает в качестве параметра предыдущее значение состояния. <br><br><b><mark>8. В чем заключаются особенности использования useEffect?</b></mark><br><br><b>useEffect</b> позволяет выполнять побочные эффекты в функциональном компоненте. Мутации, подписки, таймеры, логирование и другие побочные эффекты не должны выполняться во время первой фазы рендеринга: это может привести к ошибкам и несоответствиям в пользовательском интерфейсе.<br><br>Вместо этого рекомендуется использовать <b>useEffect</b>. <br>Функция, переданная в useEffect, будет выполняться после фазы фиксации, а если в качестве второго параметра передать массив зависимостей, то функция будет вызываться каждый раз, когда одна из зависимостей изменяется.<br><br>useEffect(() => {console.log('Logging something');}, []). <br><br><b><mark>10. Что такое реквизиты в React?</b></mark><br><br><b>Реквизиты (props, пропсы)</b> – это данные, которые передаются компоненту от родителя. Реквизиты доступны только для чтения и не могут быть изменены. <br><br><b><mark>Что такое менеджер состояний и с какими из них вы работали?</b></mark><br><br><b>Менеджер состояний</b> – это инструмент или библиотека, которая помогает управлять состоянием приложения. Менеджер предоставляет централизованное хранилище или контейнер для хранения и управления данными, которые могут быть доступны и обновлены различными компонентами приложения.<br><br>Менеджер состояния решает несколько задач. <br><b>Во-первых</b>, хорошей практикой является отделение данных и связанной с ними логики от компонентов. <br><b>Во-вторых</b>, при использовании локального состояния и передаче его между компонентами код может стать запутанным из-за возможности глубокой вложенности компонентов. При наличии глобального хранилища мы можем получать доступ к данным и изменять их из любого компонента. <br><br><b><mark>12. В каких случаях можно использовать локальное состояние, а когда следует использовать глобальное состояние?</b></mark><br><br>Локальное состояние следует применять в тех случаях, когда оно:<br><b>1.</b>Используется только в рамках одного компонента и не передается другим компонентам.<br><b>2.</b>Используется в компоненте, который представляет собой отдельный элемент списка.<br>Однако если декомпозиция компонента затрагивает вложенные компоненты, передающие данные по иерархии, лучше использовать глобальное состояние. <br><br><b><mark>20. Что такое JSX?</b></mark><br><br>Это расширение синтаксиса JavaScript. JSX позволяет использовать HTML-подобную разметку внутри JavaScript. Иными словами, это синтаксический сахар для упрощения разработки и чтения кода. <br><br><b><mark>21. Что такое пробрасывание пропсов (props drilling)?</b></mark><br><br><b>Под пробрасыванием («сверлением»)</b> реквизитов понимается процесс передачи реквизитов через несколько уровней вложенных компонентов, даже если некоторые промежуточные компоненты не используют эти пропсы напрямую. Глубокое пробрасывание делает структуру кода сложной и запутанной.<br><br>Устранить проблему пробрасывания можно с помощью контекста или библиотек управления состоянием, таких как Redux или MobX. Эти подходы позволяют получить доступ к данным через компоненты без необходимости передавать реквизиты через каждый промежуточный компонент. <br><br><b><mark>22. Как работает условный рендеринг элементов?</b></mark><br><br>Для условной отрисовки можно использовать любые условные операторы, в том числе и тернарные. <br><br><b><mark>23. Для чего и как используется UseMemo?</b></mark><br><br>Хук <b>useMemo</b> используется для кэширования и запоминания результатов вычислений. <br>В него передается функция, которая производит вычисления, и массив зависимостей. Хук будет пересчитывать значение только тогда, когда изменится одна из зависимостей – эта оптимизация помогает избежать ресурсозатратных вычислений при каждом рендере.<br>const memoValue = useMemo(() => computeFunc(paramA, paramB), [paramA, paramB]); <br><br><b><mark> 24. Для чего используется useCallback и как он работает?</b></mark><br><br> Хук <b>useCallback</b> возвращает мемоизированную версию коллбэк-функции. Эта версия будет изменяться только в том случае, если изменятся значения зависимостей в массиве зависимостей, переданном в useCallback.<br><br><b>1.</b> Хук используют для передачи функций обратного вызова в оптимизированные дочерние компоненты, которые для предотвращения лишних отрисовок полагаются на ссылочное равенство (===).<br><br><b>2 .</b> Благодаря тому, что useCallback возвращает мемоизированную версию, ссылка на коллбэк будет стабильной между рендерами, если зависимости не изменились.<br>Таким образом, useCallback позволяет оптимизировать производительность за счет избежания лишних отрисовок.<br>const callbackValue = useCallback(() => computeFunc(paramA, paramB), [paramA, paramB]); <br><br><b><mark> 25. В чем разница между useMemo и useCallback?</b></mark><br><br> Хук <b>useCallback</b> возвращает мемоизированную версию коллбэк-функции. Эта версия будет изменяться только в том случае, если изменятся значения зависимостей в массиве зависимостей, переданном в useCallback.<br><br><b>1.</b> <b>useMemo </b>используется для запоминания результата вычислений, а useCallback – для запоминания самой функции.<br><br><b>2 .</b> <b>useMemo</b> кэширует вычисленное значение и возвращает его при последующих рендерах, если зависимости не изменились.<br><br><b>3 .</b> <b>useCallback</b> кэширует саму функцию и возвращает тот же экземпляр, если зависимости не изменились. <br><br><b><mark> 28. Для чего используется useRef и как он работает?</b></mark><br><br> Хук <b>useRef</b> возвращает ссылку (ref-объект), которая может быть привязана к текущему значению какого-либо элемента или состояния компонента. При создании этого объекта, начальное значение устанавливается равным переданному аргументу. Такой объект сохраняется между различными рендерами компонента и его значение не меняется: если мы изменим значение переданного аргумента, это не повлияет на ref-объект.<br>Обычно useRef используется для доступа к дочерним элементам <b>в императивном стиле</b>, то есть явно обращаясь к какому-то элементу DOM. Это позволяет выполнять различные действия над элементом – изменять стили, добавлять события и т.д. <br><br><b><mark> 29. Что такое React.memo()?</b></mark><br><br> <b>React.memo()</b> – это компонент высшего порядка, который используется для оптимизации производительности веб-приложений. <br>Если компонент, который вы хотите оптимизировать, всегда отображает один и тот же результат с неизменными реквизитами (props), вы можете обернуть его вызов в React.memo, чтобы запомнить его результат. <br>Таким образом, React может использовать последний отрендеренный результат этого компонента вместо того, чтобы снова его рендерить, если входные данные не изменились. Это помогает оптимизировать производительность, так как повторный рендеринг может быть затратным по ресурсам. <br>Важно отметить, что React.memo влияет только на изменение входных данных (реквизитов): если функциональный компонент, обернутый в React.memo, использует useState, useReducer или useContext для изменения своего состояния или контекста, он все равно будет перерисован при изменении этих состояний или контекстов. <br><br><b><mark>34. Как отследить изменения поля объекта в функциональном компоненте?</b></mark><br><br> Для этого необходимо использовать хук useEffect и передать поле объекта в виде массива зависимостей:<br>useEffect(() => {console.log('Changed!')}, [obj.someField]). <br><br><b><mark>36. Что такое пользовательский хук?</b></mark><br><br> <b>Пользовательский хук в React </b>– это функция, которая позволяет повторно использовать логику внутри компонентов. <br>Хуки позволяют инкапсулировать определенную логику и использовать ее в разных компонентах. <br>Названия пользовательских хуков обычно начинаются с use, и они могут вызывать другие хуки при необходимости. <br><br><b><mark>39. Что такое серверный рендеринг (Server-Side Rendering)?</b></mark><br><br> <b>Серверный рендеринг (SSR)</b> – это техника, при которой сервер создает готовую к отображению веб-страницу и отправляет ее пользователю. <br>Этот подход отличается от традиционного, при котором сервер отправляет только исходный код HTML, а готовый вид страница приобретает после обработки клиентским браузером.<br><br>Основная цель серверного рендеринга – улучшение скорости загрузки страниц и повышение позиций в поисковом ранжировании. <br>Используя SSR, сервер подготавливает страницу полностью, включая динамическое содержимое. В результате пользователь получает готовую к просмотру страницу, без необходимости выполнения дополнительных запросов к серверу.<br><br>Применение SSR особенно полезно для приложений, где много контента генерируется с помощью JavaScript, так как поисковые системы не могут индексировать такой контент.<br> Используя серверный рендеринг, поисковики могут легко увидеть и проиндексировать все содержимое страницы. <br><br><b><mark>40. Перечислите преимущества серверного рендеринга.</b></mark><br><br> Серверный рендеринг имеет несколько весомых преимуществ:<br><b>1. Улучшение времени загрузки</b> – серверный рендеринг позволяет серверу отправить пользователю полностью готовую к отображению HTML-страничку, уменьшая тем самым объем обработки на стороне клиента и ускоряя загрузку страницы.<br><b>2. Улучшение видимости в поисковых системах</b> – поисковые роботы могут легко просматривать и индексировать содержание страниц, обработанных на стороне сервера, что приводит к улучшению видимости в результатах поиска.<br><b>3. Обеспечение доступности</b> – серверный рендеринг обеспечивает доступность контента для пользователей с отключенным JavaScript, гарантируя надежное и полное отображение всех страниц приложения.<br><b>4. Повышение производительности в условиях низкой скорости интернета</b – серверный рендеринг уменьшает объем данных, получаемых пользователем.<br><br>Несмотря на все преимущества SSR, важно отметить, что по сравнению с методами рендеринга на стороне клиента он может создавать большую нагрузку на сервер и усложнять обслуживание. <br>Необходимо тщательно учитывать такие факторы, как кэширование, масштабируемость и оптимизация производительности рендеринга на стороне сервера."  
  },

  {  
    "parent": "Функции",
    "title": "Функции",
    "text": "<mark><b>Что такое функция?</mark></b><br><br>Это блок кода, который объявляется один раз, но может вызываться любое количество раз.<br><br><mark><b>Что такое параметры функции?</mark></b><br><br>Это идентификаторы, которые выступают в качестве локальных переменных функции.<br><br><mark><b>Как работает оператор return в функции?</mark></b><br><br>Оператор return приводит к тому, что функция останавливает выполнение и return возвращает значение идущее после него в вызывающий код, если значения нет, тогда вернётся undefined.<br><br><mark><b>Как указать параметры по умолчанию?</mark></b><br><br>При указании списка парметров указать значение по умолчанию после знака равно.<br><br><mark><b>Что такое замыкания?</mark></b><br><br>Замыкание - это функция, у которой есть доступ к области видимости функции, внутри которой она объявлена, даже после того как эта внешняя функция завершила работу. Это значит, что в замыкании могут храниться переменные, объявленные во внешней функции и переданные ей аргументы.<br><br><mark><b>Что такое this?</mark></b><br><br><ul><li>В глобальном контексте выполнения - содержит ссылку на глобальный объект.</li><li>Внутри объекта - содержит ссылку на сам объект.</li><li>В контексте выполнения функции - значение this зависит от того как именно была вызвана функция:<ul><li>как метод объекта - this будет привязан к этому объекту</li><li>как обычная функция - this  будет привязан к глобальному объекту, в строгом режиме - undefined</li></ul></li><li>В функции-конструкторе - указывает на созданный объект</li></ul><br><br><mark><b>Что такое контекст выполнения?</mark></b><br><br><p>Это абстрактное понятие окружения, в котором код выполняется. Всякий раз, когда какой-либо код выполняется в JavaScript он запускается в контексте выполнения.</p> <p>Существует 3 типа контекстов выполнения:</p><ol><li>Глобальный - если какой-либо код находится вне функции, то он принадлежит к глобальному контексту выполнения.</li><li>Контекст выполнения функции - каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждый запуск функции имеет собственный контекст выполнения</li><li>Контекст выполнения функции eval - код, выполняемый внутри функции eval, также имеет собственный контекст выполнения.</li></ol><p>Контекст выполнения состоит из:</p><ol><li>this</li><li>Лексическое окружение (Lexical Environment) - состоит из двух частей:<ol><li>Enviroment Record - объект, в котором как свойства хранятся все переменные, функции, классы, объявленные в области видимости данного контекста.</li><li>Ссылка на внешнее лексическое окружение</li></ol></li><li>Окружение переменных (Variable Environment) - то же самое, что и лексическое окружение, только для хранения переменных объявленных с помощью var</li></ol><br><br><mark><b>Чем отличается объявление функции от выражения функции?</mark></b><br><br>Объявление функции всплывает, а выражения становятся доступны когда до них доходит выполнение<br><br><mark><b>Что такое стрелочная функция?</mark></b><br><br><p>Сокращённый синтаксис функции.<p> <ul><li>ключевое слово function не используется</li><li>имя не обязательно</li><li>для отделения параметров функции от её тела используется стрелка</li><li>если тело функции представляет собой одиночный оператор return, то можно не писать return, а просто указать возвращаемое значение</li><li>если функция имеет один параметр, то круглые скобки можно опустить, но функция без параметров должна быть записана с парой круглых скобок</li></ul><br><br><mark><b>this у стрелочных функций?</mark></b><br><br>Стрелочные функции наследуют значение this из среды, в которой были определены<br><br><mark><b>Можно ли определять стрелочные функции в качестве конструкторов для новых классов?</mark></b><br><br>Нет, они не имеют свойство prototype<br><br><mark><b>Что такое IIFE?</mark></b><br><br>Immediately Invoked Function Expression, IIFE — это функция, которая выполняется сразу же после того, как была определена. Определяется функция с помощью ключевого слова function и помещается в круглые скобки, тем самым она становится выражением и добавляются круглые скобки вызова. Такая функция создаёт внутри себя область видимости, доступ к которой есть только у неё. Таким образом мы создаём изолированный модуль.<br><br><mark><b>Особенность вложенных функций?</mark></b><br><br>Функции вложенные в другие функции имеют доступ к параметрам и переменным функций внутрь которых они вложены. Но они не наследуют значение this вмещаемой функции, у них будет свой контекст: в строгом режиме - undefined, в нестрогом - глобальный объект.<br><br><mark><b>На что указывает this в контексте вызова функции?</mark></b><br><br>В строгом режиме this будет undefined</p> <p>В нестрогом - глобальный объект.</p><p>Если вызывается как метод объекта, то this укажет на этот объект<br><br><mark><b> Что означает если вызов функции предваряется ключевым словом new?</mark></b><br><br> Это будет вызов конструктора<br><br><mark><b> Что делает вызов конструктора?</mark></b><br><br>Создаёт новый пустой объект, который унаследован от объекта, заданного свойством prototype конструктора.<br><br><mark><b> Что будет контекстом вызова функции конструктора?</mark></b><br><br>Это будет вновь созданный объект с помощью данной функции<br><br><mark><b>Что будет если функция вызывается с меньшим количеством аргументов, чем объявленных параметров.</mark></b><br><br>Если не указано значение по умолчанию, то эти параметры станут undefined<br><br><mark><b>Что такое остаточный параметр?</mark></b><br><br>Если мы вызываем функцию с количеством аргументов бОльшим, чем параметров, то мы можем сохранить все лишние аргументы в массив. Для этого нужно указать последним параметр, который предварён тремя точками<br><br><mark><b>Что такое Arguments?</mark></b><br><br>У вызовов функций есть объект Arguments, похожий на массив, который содержит аргументы функции, к которым можно обращаться по индексу. Доступ к этому объекту получаем по индентификатору arguments.<br><br><mark><b>Как работает spread оператор для функций?</mark></b><br><br>Мы можем использовать spread оператор в качестве аргумента для распаковки массива в функции, которая ожидает индивидуальные значения в параметрах<br><br><mark><b>Что такое анонимная функция?</mark></b><br><br>Это анонимное функциональное выражение, когда мы присваиваем функцию переменной. Анонимное потому что не указываем имя после слова function<br><br><mark><b>Отличие параметров от аргументов?</mark></b><br><br><p>Параметры - это переменные, которые создаются при объявлении функции</p> <p>Аргументы - это значения этих переменных во время запуска функций</p><br><br><mark><b>Значение свойства prototype у объекта функции?</mark></b><br><br>Все функции кроме стрелочных имеют свойство prototype, это объект, который по умолчанию имеет единственное свойство constructor, которое содержит ссылку на эту функцию"  
  },

  {  
    "parent": "Хостинг",
    "title": "Что такое Хостинг?",
    "text": "Простыми словами хостинг — это персональный арендованный кусочек виртуального информационного пространства, на котором вы вольны размещать свой сайт, торгового робота, 1С, CRM, любой софт, игры, тестовые и учебные стенды. Такой вот виртуальный информационный надел: вы за него платите, но всё, что с его помощью производите, получаете, зарабатываете, принадлежит вам."  
  },

  {  
    "parent": "Домен",
    "title": "Что такое Домен?",
    "text": "<mark><b>Домен</mark></b> — это уникальное название сайта или другого ресурса в Сети. Именно доменное имя люди печатают в адресной строке браузера, чтобы открыть конкретный интернет-портал или страницу. Например, чтобы зайти на страницу Яндекс Директа, достаточно набрать адрес direct.yandex.ru.<br><br>Доменное имя можно увидеть в адресной строке браузера или блоке с информацией — сниппете. Его автоматически подтягивает соцсеть, когда вы делитесь ссылкой на статью или видео.<br><br>До появления доменных имён у компьютеров в Сети были только <b>IP-адреса</b>. Это виртуальные координаты, по которым устройства связываются друг с другом в сети.<br><br>Сейчас встречаются IP двух версий — IPv4 и IPv6.<br><br>Адрес версии IPv4 выглядит как четыре числа, разделённые точками. Например, домену direct.yandex.ru соответствует IP-адрес 87.250.250.134. Эти числа показывают, на каком ресурсе в Сети хранятся данные сайта direct.yandex.ru. <br><br>В IPv6 адрес записывают с помощью восьми четырёхзначных чисел шестнадцатеричной системы счисления, а блоки с числами отделяют друг от друга двоеточиями, например 3001:0bd3:12b3:08e5:1d07:5f2e:06a2:341d.<br><br>Слово или словосочетание запомнить проще, чем набор букв или цифр. Поэтому программисты разработали систему, которая сопоставляет IP-адрес и доменное имя, когда вы печатаете его в адресной строке браузера. Она называется <b>Domain Name System, или DNS</b>.<br><br>Если компания «переезжает» со старого IP-адреса на новый, то для клиента этот процесс может пройти незаметно. Человек будет вводить привычное название ресурса, а браузер или сервер автоматически перенаправит пользователя на новую площадку."  
  },

  {  
    "parent": "DNS",
    "title": "Что такое DNS?",
    "text": "Чтобы вы могли лайкать мемы в соцсетях и смотреть гайды по Python на YouTube, вам придётся зайти на эти сайты, а браузерам — как-то найти нужные адреса. Для этого используется <mark><b>DNS (domain name system, или система доменных имён) </mark></b>, которая является чем-то вроде сталкера в мире интернета.<br><br><mark><b>DNS</mark></b> — это распределённая система, которая помогает браузерам находить адреса сайтов по их именам. Работает она благодаря разветвлённой сети серверов, на которых хранится информация обо всех сайтах интернета. То есть сам принцип работы остался прежним — база данных (табличка) с перечнем всех сайтов мира, просто заносятся в неё данные уже не вручную, одним оператором, а автоматически.<br><br>На самом деле весь интернет работает именно с <mark><b>системой IP-адресов</mark></b>, а привычные нам названия нужны только для удобства людей: их проще запоминать и вводить. Поэтому всё, что вам нужно, — написать в адресной строке браузера skillbox.ru и нажать Enter. <br><br>Дальше браузер всё сделает сам: отправит нужные запросы, разыщет IP-адрес и откроет страницу.<br><br><mark><b>Что такое DNS-сервер</mark></b><br><br>Информацию обо всех сайтах (а их очень много) нужно где-то хранить. Для этого используют DNS-серверы.<br><br>Сервер — это один или несколько специальных компьютеров, на которых хранятся IP-адреса сайтов. Каждый такой адрес привязан к своему имени, а имена нужны, чтобы их писать в адресной строке браузера.<br><br>В интернете таких серверов очень много. Они точно есть у каждого интернет-провайдера, VPN-сервиса или других IT-компаний поменьше. Через них каждую минуту проходят мегабайты информации от пользователей со всего мира.<br><br <b>Главная задача серверов</b> — хранить данные о доменах и предоставлять информацию о них по запросам пользователей. А ещё они кэшируют DNS-записи с других серверов. Это позволяет браузерам быстрее получать данные о сайтах."  
  },

  {  
    "parent": "HTTP",
    "title": "Что такое HTTP?",
    "text": "<mark><b>HTTP-протокол</mark></b> — это набор правил, по которым компьютеры обмениваются данными друг с другом. <br><br>Его инициирует <b>клиент</b> (в данном случае — человек, заходящий в интернет с любого устройства), а обрабатывает <b>сервер</b> и возвращает обратно клиенту. Между ними могут находиться <b>прокси-серверы</b>, которые занимаются дополнительными задачами — шифрованием данных, перераспределением нагрузки или кэшированием.<br><br><mark><b>Шаг первый</mark></b>  — вписываем URL в браузер<br><br>Чтобы отправить HTTP-запрос, нужно использовать URL-адрес — это «унифицированный указатель ресурса» (или Uniform Resource Locator). Он указывает браузеру, что нужно использовать HTTP-протокол, а затем получить файл с этого адреса обратно. Обычно URL-адреса начинаются с http:// или https:// (зависит от версии протокола).<br><br><mark><b>Шаг второй</mark></b>  — браузер находит IP-адрес<br><br>Для пользователей URL-адрес — это набор понятных слов: Yandex, Google. Но для компьютера эти понятные нам слова — набор непонятных символов.<br>Поэтому браузер отправляет введённые вами слова в <b>DNS</b>, преобразователь URL-адресов в IP-адреса. DNS расшифровывается как «доменная система имён» (Domain Name System), и его можно представить как огромную таблицу со всеми зарегистрированными именами для сайтов и их IP-адресами.<br><br><mark><b>Шаг третий</mark></b>  — браузер отправляет HTTP-запрос<br><br>DNS возвращает браузеру IP-адрес, с которым тот уже умеет работать. Теперь браузер начинает составлять HTTP-запрос с вложенным в него IP-адресом.<br><br>GET/HTTP/1.1<br>Host: www.yandex.ru<br><br><b>Здесь четыре элемента</b>: метод — GET, URI — /, версия HTTP — 1.1 и адрес хоста — www. yandex.ru. Давайте разберём каждый из них подробнее.<br><b>1. Метод</b> указывает, какое действие нужно совершить. <br><b>2. URI</b> — это путь до конкретного файла на сайте. <br><b>3. Версию HTTP</b>  нужно указывать, чтобы избежать ошибок.<br><b>4. Адрес хоста</b>  помогает браузеру определить, куда отправлять HTTP-запрос.<br><br><mark><b>Шаг четвёртый</mark></b>  — сервер отдаёт HTTP-ответ<br><br>После получения и обработки HTTP-запроса сервер создаёт ответ и отправляет его обратно клиенту. В нём содержатся дополнительная информация (метаданные) и запрашиваемые данные.<br><br>Здесь три главные части: <br>1. <b> Cтатус ответа</b>  — HTTP/1.1 200 OK<br>Статус ответа содержит версию HTTP-протокола, который клиент указал в HTTP-запросе. А после неё идёт код статуса ответа — 200, что означает успешное получение данных. Затем — словесное описание статуса ответа: ок.<br>2. <b> Заголовки</b>  - Content-Type и Content-Length <br>Заголовки помогают браузеру разобраться с полученными данными и представить их в правильном виде. Например, заголовок Content-Type сообщает, какой формат файла пришёл и какие у него дополнительные параметры, а Content-Length — сколько места в байтах занимает этот файл.<br>3. <b> Тело ответа</b>  — HTML-код. Рассмотрим их подробнее.<br>Тело ответа содержит в себе сам файл. Например, сервер может вернуть код HTML-документа или отправить JPEG-картинку.<br><br><mark><b>Шаг пятый</mark></b>  — браузер отображает веб-страницу.<br><br>Как только браузер получил ответ с веб-страницей, он отображает её с помощью внутреннего движка. И на этом весь процесс отправки и получение HTTP-запросов заканчивается, а клиент получает нужные ему данные."  
  },

  {  
    "parent": "Принцип работы браузера",
    "title": "Принцип работы браузера",
    "text": "<ol><li>1. Пользователь вводит URL в адресную строку браузера.</li><br><li>2. Браузер проверяет есть ли в кэше браузера сохраненная копия запрашиваемого ресурса. <br>Если ресурс найден в кэше и он актуален, то страница загружается из кэша, минуя сетевые запросы.</li><br><li>3. Если ресурс не найден в кэше, браузер выполняет запрос к DNS-серверу для преобразования доменного имени (например, www.example.com) в IP-адрес сервера.</li><br><li>4. После получения IP-адреса браузер устанавливает TCP-соединение с сервером. Этот процесс включает в себя трехэтапное рукопожатие:<ol><li>-Браузер отправляет SYN-пакет серверу.</li><li>-Сервер отвечает SYN-ACK пакетом.</li><li>-Браузер отправляет ACK-пакет, подтверждая установление соединения.</li></ol></li><br><li>5. Если URL использует HTTPS, происходит дополнительный этап установки защищенного соединения с использованием SSL/TLS: Браузер и сервер обмениваются сертификатами и выполняют шифрование данных.</li><br><li>6. Браузер отправляет HTTP-запрос на сервер.</li><br><li>7. Сервер принимает запрос, обрабатывает его, генерирует ответ и отправляет его обратно клиенту.</li><br><li>8. Браузер получает HTTP-ответ от сервера.</li><br><li>9. Браузер начинает парсинг HTML-документа. Cоздаются DOM дерево и CSSOM дерево, которые объединяются в дерево рендера</li><br><li>10. Далее происходит несколько стадий рендеринга:<ol><li>Style calculation - применение селекторов к элементам</li><li>Layout - процесс определения положения и размеров элементов из дерева рендера</li><li>Paint - отрисовка согласно стилям</li><li>Compositing - распределение элементов по слоям</li></ol></li><br><li>11. Страница отображается пользователю.</li></ol>"  
  }
]
